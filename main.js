/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source, please visit the github repository of this plugin
*/

'use strict';

var obsidian = require('obsidian');

/**
 * Chronica - Life in Frames Plugin for Obsidian
 *
 * A powerful visualization tool to track your life in weeks, inspired by
 * the "Life in Weeks" concept. Allows tracking of major life events,
 * reflections, and plans across multiple time scales.
 */
// -----------------------------------------------------------------------
// CONSTANTS & TYPE DEFINITIONS
// -----------------------------------------------------------------------
/** Unique identifier for the timeline view */
const TIMELINE_VIEW_TYPE = "chronica-timeline-view";
/**
 * Suggest-modal that lists every vault folder path.
 */
class FolderSuggest extends obsidian.AbstractInputSuggest {
    inputEl;
    plugin;
    constructor(app, inputEl, plugin) {
        super(app, inputEl);
        this.inputEl = inputEl;
        this.plugin = plugin;
    }
    getSuggestions(query) {
        const results = [];
        const traverse = (folder) => {
            results.push(folder.path);
            folder.children.forEach((child) => {
                if (child instanceof obsidian.TFolder) {
                    traverse(child);
                }
            });
        };
        traverse(this.app.vault.getRoot());
        return results.filter((f) => f.toLowerCase().includes(query.toLowerCase()));
    }
    renderSuggestion(item, el) {
        el.createEl("div", { text: item });
        el.addEventListener("click", (evt) => {
            this.onChooseSuggestion(item, evt);
        });
    }
    onChooseSuggestion(item, evt) {
        this.inputEl.value = item;
        this.plugin.settings.notesFolder = item;
        this.plugin.saveSettings();
        this.inputEl.dispatchEvent(new Event("input", { bubbles: true }));
        this.close();
    }
}
/** Default plugin settings */
const DEFAULT_SETTINGS = {
    birthday: "2003-07-18",
    lifespan: 90,
    defaultView: "weeks",
    pastCellColor: "#6A7BA3",
    presentCellColor: "#a882ff",
    futureCellColor: "#d8e2e6",
    greenEvents: [],
    blueEvents: [],
    pinkEvents: [],
    purpleEvents: [],
    customEventTypes: [],
    customEvents: {},
    quote: "the only true luxury is time.",
    notesFolder: "",
    showDecadeMarkers: true,
    showWeekMarkers: true,
    showMonthMarkers: false,
    showBirthdayMarker: true,
    monthMarkerFrequency: "all",
    enableManualFill: false,
    enableAutoFill: true,
    autoFillDay: 1,
    filledWeeks: [],
    startWeekOnMonday: true,
    zoomLevel: 1.0,
    defaultFitToScreen: false,
    isSidebarOpen: false,
    cellShape: "square",
    gridOrientation: "landscape",
    isStatsOpen: false,
    activeStatsTab: "overview",
    statsPanelHeight: 470,
    statsPanelHorizontalOffset: 0,
    statsPanelWidth: 700,
};
/** SVG icon for the Chronica Timeline */
const CHRONOS_ICON = `<svg viewBox="0 0 100 100" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" stroke-width="4"/>
  <line x1="50" y1="15" x2="50" y2="50" stroke="currentColor" stroke-width="4"/>
  <line x1="50" y1="50" x2="75" y2="60" stroke="currentColor" stroke-width="4"/>
  <circle cx="50" cy="50" r="5" fill="currentColor"/>
</svg>`;
// Gap between decades (larger than regular gap)
const DECADE_GAP = 6; // px
// Month names for display
const MONTH_NAMES = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
];
// -----------------------------------------------------------------------
// MAIN PLUGIN CLASS
// -----------------------------------------------------------------------
/**
 * Main plugin class that handles initialization, settings, and view management
 */
class ChronosTimelinePlugin extends obsidian.Plugin {
    /** Plugin settings */
    settings = DEFAULT_SETTINGS;
    /**
     * Plugin initialization on load
     */
    async onload() {
        console.log("Loading Chronica Timeline Plugin");
        // 1) Register the timeline view exactly once
        try {
            this.registerView(TIMELINE_VIEW_TYPE, (leaf) => new ChronosTimelineView(leaf, this));
        }
        catch (e) {
            // already registered on hot-reload—ignore
        }
        // 2) Re-draw whenever a new weekly note appears
        this.registerEvent(this.app.vault.on("create", () => {
            this.registerPotentialSyncOperation();
            // Only refresh if not during a likely sync operation
            if (!this.isSyncOperation) {
                this.refreshAllViews();
            }
        }));
        this.registerEvent(this.app.vault.on("modify", () => {
            this.registerPotentialSyncOperation();
        }));
        // 3) On deletion, remove from settings AND re-draw
        this.registerEvent(this.app.vault.on("delete", async (file) => {
            if (!(file instanceof obsidian.TFile))
                return;
            // 1) Only run on notes named like "2025--W23.md"
            const base = file.basename; // e.g. "2025--W23"
            if (!/^\d{4}--W\d{2}$/.test(base))
                return; // skip everything else
            // 2) Normalize to "2025-W23" so it matches your settings entries
            const weekKey = base.replace("--", "-");
            // 3) Purge it from every array, same as before
            const purge = (arr) => arr.filter((e) => e.split(":")[0] !== weekKey);
            this.settings.greenEvents = purge(this.settings.greenEvents);
            this.settings.blueEvents = purge(this.settings.blueEvents);
            this.settings.pinkEvents = purge(this.settings.pinkEvents);
            this.settings.purpleEvents = purge(this.settings.purpleEvents);
            if (this.settings.customEventTypes) {
                for (const t of this.settings.customEventTypes) {
                    const list = this.settings.customEvents[t.name] || [];
                    this.settings.customEvents[t.name] = purge(list);
                }
            }
            // 4) Save & redraw
            await this.saveSettings();
            this.refreshAllViews();
        }));
        // 4) Now your regular setup
        obsidian.addIcon("chronica-icon", CHRONOS_ICON);
        await this.loadSettings();
        await this.scanVaultForEvents();
        this.addRibbonIcon("chronica-icon", "Open Chronica Timeline", () => {
            this.activateView();
        });
        // Add command to open timeline
        this.addCommand({
            id: "open-chronica-timeline",
            name: "Open Chronica Timeline",
            callback: () => {
                this.activateView();
            },
        });
        // Command to create/open weekly note
        this.addCommand({
            id: "create-weekly-note",
            name: "Create/Open Current Week Note",
            callback: () => {
                this.createOrOpenWeekNote();
            },
        });
        // Add settings tab
        this.addSettingTab(new ChronosSettingTab(this.app, this));
        // Check for auto-fill on plugin load
        this.checkAndAutoFill();
        // Register interval to check for auto-fill (check every hour)
        this.registerInterval(window.setInterval(() => this.checkAndAutoFill(), 1000 * 60 * 60));
    }
    /**
     * Scan vault for notes with event metadata and populate plugin settings
     */
    async scanVaultForEvents() {
        console.log("Scanning vault for event metadata...");
        // Get all markdown files in the vault
        const files = this.app.vault.getMarkdownFiles();
        // Track how many event notes we find
        let eventCount = 0;
        // Map to track range events so we can parse them fully
        const rangeEventMap = new Map();
        // Process each file
        for (const file of files) {
            try {
                // Convert basename to a consistent format - handle both "2023-W15" and "2023--W15" formats
                let normalizedBasename = file.basename;
                normalizedBasename = normalizedBasename.replace(/--W/, "-W"); // Convert 2023--W15 to 2023-W15
                // Check if the filename matches our weekly note pattern (both potential formats)
                // Regular week format (single week): 2023-W15.md or 2023--W15.md
                const weekPattern = /(\d{4}-W\d{2})/;
                // Range format: 2023-W15_to_2023-W20.md or 2023--W15_to_2023--W20.md
                const rangePattern = /(\d{4}-W\d{2})_to_(\d{4}-W\d{2})/;
                let weekKey = null;
                let endWeekKey = null;
                let isRange = false;
                // Check for single week pattern
                const weekMatch = normalizedBasename.match(weekPattern);
                if (weekMatch) {
                    weekKey = weekMatch[1];
                }
                // Check for range pattern
                const rangeMatch = normalizedBasename.match(rangePattern);
                if (rangeMatch) {
                    weekKey = rangeMatch[1];
                    endWeekKey = rangeMatch[2];
                    isRange = true;
                }
                // If it's neither a week nor a range, skip
                if (!weekKey)
                    continue;
                // Read file content
                const content = await this.app.vault.read(file);
                // Check for YAML frontmatter
                const frontmatterMatch = content.match(/^---\s+([\s\S]*?)\s+---/);
                if (!frontmatterMatch)
                    continue;
                // Parse frontmatter
                const frontmatter = frontmatterMatch[1];
                const metadata = {};
                frontmatter.split("\n").forEach((line) => {
                    const match = line.match(/^([^:]+):\s*(.+)$/);
                    if (match) {
                        const [_, key, value] = match;
                        metadata[key.trim()] = value.trim().replace(/^"(.*)"$/, "$1");
                    }
                });
                // If no event or type, skip
                if (!metadata.event && !metadata.name)
                    continue;
                const eventName = metadata.event || metadata.name;
                const eventType = metadata.type || "Major Life";
                const description = metadata.description || eventName;
                // Check if this is part of a range event by looking at startDate and endDate in metadata
                if (metadata.startDate && metadata.endDate && !isRange) {
                    // This is a single week note that's part of a range event
                    const startDate = new Date(metadata.startDate);
                    const endDate = new Date(metadata.endDate);
                    // Generate a unique ID for this range event
                    const rangeId = `${eventName}-${startDate.toISOString()}-${endDate.toISOString()}`;
                    // If we haven't seen this range before, create it
                    if (!rangeEventMap.has(rangeId)) {
                        // Convert dates to week keys
                        const startWeek = this.getWeekKeyFromDate(startDate);
                        const endWeek = this.getWeekKeyFromDate(endDate);
                        rangeEventMap.set(rangeId, {
                            startWeek,
                            endWeek,
                            description,
                            type: eventType,
                            color: metadata.color || "",
                        });
                    }
                    // We'll process this note as part of a range later
                    continue;
                }
                // Format event string based on whether it's a range
                let eventString = "";
                if (isRange && endWeekKey) {
                    eventString = `${weekKey}:${endWeekKey}:${description}`;
                }
                else {
                    eventString = `${weekKey}:${description}`;
                }
                // Add to appropriate collection if not already present
                let added = false;
                switch (eventType) {
                    case "Major Life":
                        if (!this.settings.greenEvents.includes(eventString)) {
                            this.settings.greenEvents.push(eventString);
                            added = true;
                        }
                        break;
                    case "Travel":
                        if (!this.settings.blueEvents.includes(eventString)) {
                            this.settings.blueEvents.push(eventString);
                            added = true;
                        }
                        break;
                    case "Relationship":
                        if (!this.settings.pinkEvents.includes(eventString)) {
                            this.settings.pinkEvents.push(eventString);
                            added = true;
                        }
                        break;
                    case "Education/Career":
                        if (!this.settings.purpleEvents.includes(eventString)) {
                            this.settings.purpleEvents.push(eventString);
                            added = true;
                        }
                        break;
                    default:
                        // Handle custom event types
                        if (this.settings.customEventTypes) {
                            const customType = this.settings.customEventTypes.find((t) => t.name === eventType);
                            if (customType) {
                                if (!this.settings.customEvents[eventType]) {
                                    this.settings.customEvents[eventType] = [];
                                }
                                if (!this.settings.customEvents[eventType].includes(eventString)) {
                                    this.settings.customEvents[eventType].push(eventString);
                                    added = true;
                                }
                            }
                        }
                        break;
                }
                if (added) {
                    eventCount++;
                }
            }
            catch (error) {
                console.error("Error processing file:", file.path, error);
            }
        }
        // Process the range events we collected
        for (const rangeEvent of rangeEventMap.values()) {
            const eventString = `${rangeEvent.startWeek}:${rangeEvent.endWeek}:${rangeEvent.description}`;
            // Add to appropriate collection if not already present
            let added = false;
            switch (rangeEvent.type) {
                case "Major Life":
                    if (!this.settings.greenEvents.includes(eventString)) {
                        this.settings.greenEvents.push(eventString);
                        added = true;
                    }
                    break;
                case "Travel":
                    if (!this.settings.blueEvents.includes(eventString)) {
                        this.settings.blueEvents.push(eventString);
                        added = true;
                    }
                    break;
                case "Relationship":
                    if (!this.settings.pinkEvents.includes(eventString)) {
                        this.settings.pinkEvents.push(eventString);
                        added = true;
                    }
                    break;
                case "Education/Career":
                    if (!this.settings.purpleEvents.includes(eventString)) {
                        this.settings.purpleEvents.push(eventString);
                        added = true;
                    }
                    break;
                default:
                    // Handle custom event types
                    if (this.settings.customEventTypes) {
                        const customType = this.settings.customEventTypes.find((t) => t.name === rangeEvent.type);
                        if (customType) {
                            if (!this.settings.customEvents[rangeEvent.type]) {
                                this.settings.customEvents[rangeEvent.type] = [];
                            }
                            if (!this.settings.customEvents[rangeEvent.type].includes(eventString)) {
                                this.settings.customEvents[rangeEvent.type].push(eventString);
                                added = true;
                            }
                        }
                    }
                    break;
            }
            if (added) {
                eventCount++;
            }
        }
        if (eventCount > 0) {
            console.log(`Found ${eventCount} events from note metadata`);
            await this.saveSettings();
        }
    }
    refreshAllViews() {
        // Skip refreshing during likely sync operations
        if (this.isSyncOperation) {
            console.log("Skipping refresh during potential sync operation");
            return;
        }
        this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
            leaf.view.renderView();
        });
    }
    /**
     * Load settings from storage
     */
    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
        // Initialize empty arrays/objects if they don't exist
        if (!this.settings.customEventTypes) {
            this.settings.customEventTypes = [];
        }
        if (!this.settings.customEvents) {
            this.settings.customEvents = {};
        }
        // Initialize new marker settings if they don't exist
        if (this.settings.showDecadeMarkers === undefined) {
            this.settings.showDecadeMarkers = DEFAULT_SETTINGS.showDecadeMarkers;
        }
        if (this.settings.showWeekMarkers === undefined) {
            this.settings.showWeekMarkers = DEFAULT_SETTINGS.showWeekMarkers;
        }
        if (this.settings.showMonthMarkers === undefined) {
            this.settings.showMonthMarkers = DEFAULT_SETTINGS.showMonthMarkers;
        }
        if (this.settings.showBirthdayMarker === undefined) {
            this.settings.showBirthdayMarker = DEFAULT_SETTINGS.showBirthdayMarker;
        }
        if (this.settings.monthMarkerFrequency === undefined) {
            this.settings.monthMarkerFrequency =
                DEFAULT_SETTINGS.monthMarkerFrequency;
            // Initialize new fill settings if they don't exist
            if (this.settings.enableManualFill === undefined) {
                this.settings.enableManualFill = DEFAULT_SETTINGS.enableManualFill;
            }
            if (this.settings.enableAutoFill === undefined) {
                this.settings.enableAutoFill = DEFAULT_SETTINGS.enableAutoFill;
            }
            if (this.settings.autoFillDay === undefined) {
                this.settings.autoFillDay = DEFAULT_SETTINGS.autoFillDay;
            }
            if (this.settings.filledWeeks === undefined) {
                this.settings.filledWeeks = DEFAULT_SETTINGS.filledWeeks;
            }
            if (this.settings.startWeekOnMonday === undefined) {
                this.settings.startWeekOnMonday = DEFAULT_SETTINGS.startWeekOnMonday;
            }
        }
    }
    /**
     * Check if the current week should be auto-filled
     * @returns true if the current week was filled
     */
    checkAndAutoFill() {
        if (!this.settings.enableAutoFill) {
            return false;
        }
        // Get current date and day of week
        const now = new Date();
        const currentDay = now.getDay(); // 0-6, 0 is Sunday
        // Only proceed if today is the configured auto-fill day
        if (currentDay !== this.settings.autoFillDay) {
            return false;
        }
        // Get current week key
        const currentWeekKey = this.getWeekKeyFromDate(now);
        // Check if this week is already filled
        if (this.settings.filledWeeks.includes(currentWeekKey)) {
            return false;
        }
        // Add current week to filled weeks
        this.settings.filledWeeks.push(currentWeekKey);
        this.saveSettings();
        return true;
    }
    /**
     * Save settings to storage
     */
    async saveSettings() {
        await this.saveData(this.settings);
    }
    /**
     * Show or focus the timeline view
     */
    async activateView() {
        const { workspace } = this.app;
        // Check if view is already open
        let leaf = workspace.getLeavesOfType(TIMELINE_VIEW_TYPE)[0];
        if (!leaf) {
            // Create a new leaf in the right sidebar
            leaf = workspace.getLeaf("split", "vertical");
            await leaf.setViewState({
                type: TIMELINE_VIEW_TYPE,
                active: true,
            });
        }
        // Reveal and focus the leaf
        workspace.revealLeaf(leaf);
    }
    /**
     * Calculate full weeks between birthday and given date
     * @param birthday - Birth date
     * @param today - Current or target date
     * @returns Number of full weeks between dates
     */
    getFullWeekAge(birthday, today) {
        // First, create copies to avoid modifying the original dates
        const birthdayClone = new Date(birthday.getTime());
        const todayClone = new Date(today.getTime());
        // Normalize both dates to start of day
        birthdayClone.setHours(0, 0, 0, 0);
        todayClone.setHours(0, 0, 0, 0);
        // Calculate milliseconds between dates
        const diffMs = todayClone.getTime() - birthdayClone.getTime();
        const msPerWeek = 1000 * 60 * 60 * 24 * 7;
        // Return full weeks
        return Math.floor(diffMs / msPerWeek);
    }
    /**
     * Get full path for a note, using settings folder if specified
     * @param fileName - Name of the file
     * @returns Full path including folder if specified
     */
    getFullPath(fileName) {
        if (this.settings.notesFolder && this.settings.notesFolder.trim() !== "") {
            let folderPath = this.settings.notesFolder;
            if (!folderPath.endsWith("/")) {
                folderPath += "/";
            }
            return `${folderPath}${fileName}`;
        }
        return fileName;
    }
    /**
     * Create or open a note for the current week
     */
    async createOrOpenWeekNote() {
        try {
            const date = new Date();
            const year = date.getFullYear();
            const weekNum = this.getISOWeekNumber(date);
            const fileName = `${year}-W${weekNum.toString().padStart(2, "0")}.md`;
            const fullPath = this.getFullPath(fileName);
            const weekKey = `${year}-W${weekNum.toString().padStart(2, "0")}`;
            const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
            if (existingFile instanceof obsidian.TFile) {
                // Use our safe method instead of directly opening in active leaf
                await this.safelyOpenFile(existingFile);
            }
            else {
                // Create folder if needed
                if (this.settings.notesFolder &&
                    this.settings.notesFolder.trim() !== "") {
                    try {
                        const folderExists = this.app.vault.getAbstractFileByPath(this.settings.notesFolder);
                        if (!folderExists) {
                            await this.app.vault.createFolder(this.settings.notesFolder);
                        }
                    }
                    catch (err) {
                        console.log("Error checking/creating folder:", err);
                    }
                }
                // Check if any events exist for this week in the plugin settings
                let content = "";
                let eventMeta = null;
                // Check built-in event types
                const eventTypes = [
                    {
                        events: this.settings.greenEvents,
                        type: "Major Life",
                        color: "#4CAF50",
                    },
                    {
                        events: this.settings.blueEvents,
                        type: "Travel",
                        color: "#2196F3",
                    },
                    {
                        events: this.settings.pinkEvents,
                        type: "Relationship",
                        color: "#E91E63",
                    },
                    {
                        events: this.settings.purpleEvents,
                        type: "Education/Career",
                        color: "#D2B55B",
                    },
                ];
                // [KEEP THE REST OF THE EXISTING EVENT DETECTION LOGIC]
                // Add frontmatter if event exists
                if (eventMeta) ;
                else {
                    // Add empty frontmatter
                    content = this.formatFrontmatter({});
                }
                // Add note template
                content += `# Week ${weekNum}, ${year}\n\n## Reflections\n\n## Tasks\n\n## Notes\n`;
                const newFile = await this.app.vault.create(fullPath, content);
                // Use our safe method instead of directly opening in active leaf
                await this.safelyOpenFile(newFile);
            }
        }
        catch (error) {
            new obsidian.Notice(`Error creating week note: ${error}`);
        }
    }
    /**
     * Calculate ISO week number and the associated ISO year for a given date
     * @param date - Date to calculate week number for
     * @returns Object with ISO week number (1-53) and ISO year
     */
    getISOWeekYearNumber(date) {
        // Create a copy of the date to avoid modifying the original
        const target = new Date(date.getTime());
        target.setHours(0, 0, 0, 0);
        // ISO week starts on Monday
        const dayNumber = target.getDay() || 7; // Convert Sunday (0) to 7
        // Move target to Thursday in the same week
        target.setDate(target.getDate() - dayNumber + 4);
        // Get the year of this Thursday (this is the ISO year for this week)
        const weekYear = target.getFullYear();
        // Get January 1st of the target's year
        const yearStart = new Date(weekYear, 0, 1);
        // Calculate the number of days since January 1st
        const daysSinceFirstDay = Math.floor((target.getTime() - yearStart.getTime()) / 86400000);
        // Calculate the week number
        const weekNumber = 1 + Math.floor(daysSinceFirstDay / 7);
        return { week: weekNumber, year: weekYear };
    }
    /**
     * Get the ISO week and year for a given date following strict ISO 8601 standard
     * @param date - Date to calculate for
     * @returns Object with week number and correct ISO year
     */
    getISOWeekData(date) {
        // Create a copy to avoid modifying the original
        const d = new Date(date.getTime());
        // Get the day of week (0 = Sunday, 1 = Monday, etc.)
        const dayOfWeek = d.getDay();
        // Set to nearest Thursday (current date + 4 - current day number)
        d.setDate(d.getDate() + 4 - (dayOfWeek || 7));
        // Get first day of this ISO year (January 1st)
        const yearStart = new Date(d.getFullYear(), 0, 1);
        // Calculate days between date and first day of year, plus 1 day
        const days = Math.floor((d.getTime() - yearStart.getTime()) / 86400000) + 1;
        // Calculate the ISO week number
        const weekNum = Math.ceil(days / 7);
        // Check for edge cases at year boundaries
        if (weekNum === 0) {
            // Week belongs to the previous year
            // Find the last week of previous year
            const lastDayPrevYear = new Date(d.getFullYear() - 1, 11, 31);
            const lastWeekData = this.getISOWeekData(lastDayPrevYear);
            return lastWeekData;
        }
        else if (weekNum > 52) {
            // Check if it's actually week 1 of next year
            const dec31 = new Date(d.getFullYear(), 11, 31);
            const dec31Day = dec31.getDay();
            // If Dec 31 is on Wed-Sun, the last days are week 1 of next year
            if (dec31Day >= 3) {
                return { week: 1, year: d.getFullYear() + 1 };
            }
        }
        return { week: weekNum, year: d.getFullYear() };
    }
    /**
     * Calculate ISO week number for a given date
     * @param date - Date to calculate week number for
     * @returns ISO week number (1-53)
     */
    getISOWeekNumber(date) {
        return this.getISOWeekData(date).week;
    }
    /**
     * Get week key in YYYY-WXX format from date with corrected year
     * @param date - Date to get week key for
     * @returns Week key in YYYY-WXX format
     */
    getWeekKeyFromDate(date) {
        const { week, year } = this.getISOWeekYearNumber(date);
        return `${year}-W${week.toString().padStart(2, "0")}`;
    }
    /**
     * Get all week keys between two dates
     * @param startDate - Start date
     * @param endDate - End date
     * @returns Array of week keys in YYYY-WXX format
     */
    getWeekKeysBetweenDates(startDate, endDate) {
        const weekKeys = [];
        const currentDate = new Date(startDate);
        // Ensure dates are in order
        if (startDate > endDate) {
            const temp = startDate;
            startDate = endDate;
            endDate = temp;
        }
        // Get week key for starting date
        let currentWeekKey = this.getWeekKeyFromDate(currentDate);
        weekKeys.push(currentWeekKey);
        // Advance by one week until we reach or pass the end date
        while (currentDate < endDate) {
            // Move to next week
            currentDate.setDate(currentDate.getDate() + 7);
            // Check if we've gone past the end date
            if (currentDate > endDate) {
                break;
            }
            // Get week key and add to array
            currentWeekKey = this.getWeekKeyFromDate(currentDate);
            // Only add if not already in the array (avoid duplicates)
            if (!weekKeys.includes(currentWeekKey)) {
                weekKeys.push(currentWeekKey);
            }
        }
        // Ensure the end date's week is included
        const endWeekKey = this.getWeekKeyFromDate(endDate);
        if (!weekKeys.includes(endWeekKey)) {
            weekKeys.push(endWeekKey);
        }
        return weekKeys;
    }
    /**
     * Calculate the horizontal position for a given year, accounting for decade gaps
     * @param year - Year to calculate position for (0-based index from birth)
     * @param cellSize - Size of each cell in pixels
     * @param cellGap - Standard gap between cells in pixels
     * @returns Position in pixels
     */
    calculateYearPosition(year, cellSize, cellGap) {
        // Add extra space for each completed decade
        const decades = Math.floor(year / 10);
        const extraGap = DECADE_GAP - cellGap; // Additional space for each decade
        return year * (cellSize + cellGap) + decades * extraGap;
    }
    /**
     * Calculate month positions for vertical markers based on birth date
     * @param birthdayDate - User's birth date
     * @param totalYears - Total years to display on timeline
     * @param frequency - How often to show month markers ('all', 'quarter', 'half-year', 'year')
     * @returns Array of objects with month marker data
     */
    calculateMonthMarkers(birthdayDate, totalYears, frequency = "all") {
        const monthMarkers = [];
        // Clone the birthday date to avoid modifying the original
        const startDate = new Date(birthdayDate.getTime());
        startDate.setHours(0, 0, 0, 0);
        // Calculate the end date (birthday + total years)
        const endDate = new Date(startDate.getTime());
        endDate.setFullYear(endDate.getFullYear() + totalYears);
        // Get the birth month and year for special handling
        const birthMonth = startDate.getMonth();
        const birthYear = startDate.getFullYear();
        // Create a calendar date iterator starting from birthday
        const currentDate = new Date(startDate.getTime());
        // Keep track of previously added month/year to avoid duplicates
        let lastMarkedMonth = -1;
        let lastMarkedYear = -1;
        // Helper to determine if a month should be shown based on frequency
        const shouldShowMonth = (monthNum) => {
            // Always show January and birth month
            if (monthNum === 0 || monthNum === birthMonth)
                return true;
            switch (frequency) {
                case "all":
                    return true;
                case "quarter":
                    // Show Jan, Apr, Jul, Oct
                    return monthNum % 3 === 0;
                case "half-year":
                    // Show Jan, Jul
                    return monthNum % 6 === 0;
                case "year":
                    // Only show January and birth month
                    return monthNum === 0 || monthNum === birthMonth;
                default:
                    return true;
            }
        };
        // Iterate by weeks until we reach the end date
        while (currentDate < endDate) {
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            // Check if this is a new month that should be shown
            if ((currentMonth !== lastMarkedMonth || currentYear !== lastMarkedYear) &&
                shouldShowMonth(currentMonth)) {
                // Calculate exact week index relative to birth date
                const weeksSinceBirth = this.getFullWeekAge(birthdayDate, currentDate);
                // Add marker for this month
                monthMarkers.push({
                    weekIndex: weeksSinceBirth,
                    label: MONTH_NAMES[currentMonth],
                    isFirstOfYear: currentMonth === 0,
                    isBirthMonth: currentMonth === birthMonth && currentYear === birthYear,
                    fullLabel: `${MONTH_NAMES[currentMonth]} ${currentYear}`,
                    monthNumber: currentMonth + (currentYear - birthYear) * 12, // Add this line
                });
                // Update last marked month/year
                lastMarkedMonth = currentMonth;
                lastMarkedYear = currentYear;
            }
            // Move forward one week at a time
            currentDate.setDate(currentDate.getDate() + 7);
        }
        // Sort by week index
        monthMarkers.sort((a, b) => a.weekIndex - b.weekIndex);
        return monthMarkers;
    }
    /**
     * Calculate date range for a given week key
     * @param weekKey - Week key in YYYY-WXX format
     * @returns String with formatted date range
     */
    getWeekDateRange(weekKey) {
        const parts = weekKey.split("-W");
        if (parts.length !== 2)
            return "";
        const year = parseInt(parts[0]);
        const week = parseInt(parts[1]);
        // Find January 4th for the given year, which is always in week 1
        const jan4 = new Date(year, 0, 4);
        // Find the Monday of week 1
        const week1Start = this.getStartOfISOWeek(jan4);
        // Calculate the first day of the target week
        const firstDayOfWeek = new Date(week1Start);
        firstDayOfWeek.setDate(week1Start.getDate() + (week - 1) * 7);
        // Calculate the last day of the week (Sunday)
        const lastDayOfWeek = new Date(firstDayOfWeek);
        lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
        // Format the dates
        const formatDate = (date) => {
            const months = [
                "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
            ];
            return `${months[date.getMonth()]} ${date.getDate()}`;
        };
        return `${formatDate(firstDayOfWeek)} - ${formatDate(lastDayOfWeek)}`;
    }
    /**
     * Calculate the birthday date for a specific age year
     * @param birthDate - Original birth date
     * @param ageYear - Age year to calculate for (0-based, 0 = birth year)
     * @returns Date object representing the birthday in that age year
     */
    calculateBirthdayInYear(birthDate, ageYear) {
        const targetDate = new Date(birthDate);
        targetDate.setFullYear(birthDate.getFullYear() + ageYear);
        return targetDate;
    }
    /**
     * Calculate which ISO week number contains the birthday in a specific year
     * @param year - Year to check
     * @returns ISO week number (1-53) containing the birthday
     */
    getBirthdayWeekForYear(year) {
        // Get the birthday in this specific year
        const birthdayDate = new Date(this.settings.birthday);
        birthdayDate.setFullYear(year);
        // Calculate the ISO week data
        const { week, year: isoYear } = this.getISOWeekData(birthdayDate);
        // If the ISO year is different than the calendar year
        if (isoYear !== year) {
            // We need to find a date that's definitely in the requested year
            // Let's use January 4th which is always in week 1 of the ISO year
            const jan4 = new Date(year, 0, 4);
            const jan4Data = this.getISOWeekData(jan4);
            const weekStart = this.getStartOfISOWeek(jan4);
            return {
                weekNumber: jan4Data.week,
                weekStart: weekStart
            };
        }
        // Find the Monday that starts this ISO week
        const weekStart = this.getStartOfISOWeek(birthdayDate);
        return {
            weekNumber: week,
            weekStart: weekStart
        };
    }
    /**
     * Get the start date (Monday) of the ISO week containing the given date
     * @param date - Date to find the containing week for
     * @returns Date object representing the start of the week (Monday)
     */
    getStartOfISOWeek(date) {
        const tempDate = new Date(date.getTime());
        const dayOfWeek = tempDate.getDay() || 7; // Convert Sunday (0) to 7
        // Move to the Monday of the current week (ISO week starts on Monday)
        if (dayOfWeek !== 1) {
            tempDate.setDate(tempDate.getDate() - (dayOfWeek - 1));
        }
        // Reset time to start of day
        tempDate.setHours(0, 0, 0, 0);
        return tempDate;
    }
    /**
     * Get event metadata from a note
     * @param weekKey - Week key in YYYY-WXX format
     * @returns Event metadata if found
     */
    async getEventFromNote(weekKey) {
        const fileName = `${weekKey.replace("W", "-W")}.md`;
        const fullPath = this.getFullPath(fileName);
        // Check if file exists
        const file = this.app.vault.getAbstractFileByPath(fullPath);
        if (!(file instanceof obsidian.TFile)) {
            return null;
        }
        // Read file content
        const content = await this.app.vault.read(file);
        // Check for YAML frontmatter
        const frontmatterMatch = content.match(/^---\s+([\s\S]*?)\s+---/);
        if (!frontmatterMatch) {
            return null;
        }
        // Parse YAML frontmatter
        try {
            const frontmatter = frontmatterMatch[1];
            const metadata = {};
            // Simple YAML parsing (not using an external parser for simplicity)
            frontmatter.split("\n").forEach((line) => {
                const match = line.match(/^([^:]+):\s*(.+)$/);
                if (match) {
                    const [_, key, value] = match;
                    metadata[key.trim()] = value.trim().replace(/^"(.*)"$/, "$1");
                }
            });
            return {
                event: metadata.event || metadata.name,
                name: metadata.name || metadata.event,
                description: metadata.description,
                type: metadata.type,
                color: metadata.color,
                startDate: metadata.startDate,
                endDate: metadata.endDate,
            };
        }
        catch (error) {
            console.log("Error parsing frontmatter:", error);
            return null;
        }
    }
    /**
     * Update or add event metadata to a note
     * @param weekKey - Week key in YYYY-WXX format
     * @param metadata - Event metadata to add
     * @returns True if successful
     */
    async updateEventInNote(weekKey, metadata) {
        const fileName = `${weekKey.replace("W", "-W")}.md`;
        const fullPath = this.getFullPath(fileName);
        // Check if file exists
        let file = this.app.vault.getAbstractFileByPath(fullPath);
        let content = "";
        if (file instanceof obsidian.TFile) {
            // Read existing content
            content = await this.app.vault.read(file);
            // Replace existing frontmatter or add new frontmatter
            const hasFrontmatter = content.match(/^---\s+[\s\S]*?\s+---/);
            if (hasFrontmatter) {
                // Replace existing frontmatter
                content = content.replace(/^---\s+[\s\S]*?\s+---/, this.formatFrontmatter(metadata));
            }
            else {
                // Add frontmatter at the beginning
                content = this.formatFrontmatter(metadata) + content;
            }
            // Update file
            await this.app.vault.modify(file, content);
        }
        else {
            // Create new file with frontmatter and basic template
            content = this.formatFrontmatter(metadata);
            // Add basic template
            const weekNum = parseInt(weekKey.split("-W")[1]);
            const year = parseInt(weekKey.split("-")[0]);
            content += `# Week ${weekNum}, ${year}\n\n## Reflections\n\n## Tasks\n\n## Notes\n\n`;
            // Create folder if needed
            if (this.settings.notesFolder &&
                this.settings.notesFolder.trim() !== "") {
                try {
                    const folderExists = this.app.vault.getAbstractFileByPath(this.settings.notesFolder);
                    if (!folderExists) {
                        await this.app.vault.createFolder(this.settings.notesFolder);
                    }
                }
                catch (err) {
                    console.log("Error checking/creating folder:", err);
                }
            }
            // Create file
            await this.app.vault.create(fullPath, content);
        }
        return true;
    }
    /**
     * Format metadata as YAML frontmatter
     * @param metadata - Event metadata
     * @returns Formatted frontmatter string
     */
    formatFrontmatter(metadata) {
        let frontmatter = "---\n";
        // If both event and name are the same value, only include name
        if (metadata.event && metadata.name && metadata.event === metadata.name) {
            const { event, ...rest } = metadata; // Remove event property
            metadata = rest;
        }
        // Add each metadata field
        Object.entries(metadata).forEach(([key, value]) => {
            if (value !== undefined && value !== null && value !== "") {
                // If value contains special characters, wrap in quotes
                const needsQuotes = /[:#\[\]{}|>*&!%@,]/.test(String(value));
                const formattedValue = needsQuotes ? `"${value}"` : value;
                frontmatter += `${key}: ${formattedValue}\n`;
            }
        });
        frontmatter += "---\n\n";
        return frontmatter;
    }
    /**
     * Handle file deletion and remove any associated events
     * @param file - File that was deleted
     */
    async handleFileDelete(file) {
        // Check if the file is a week or event note
        const filePath = file.path;
        const fileName = filePath.split("/").pop() || "";
        // Check if it matches our event file naming pattern
        const weekPattern = /(\d{4}-W\d{2})\.md$/;
        const rangePattern = /(\d{4}-W\d{2})_to_(\d{4}-W\d{2})\.md$/;
        let weekKeys = [];
        // Single week file
        const weekMatch = fileName.match(weekPattern);
        if (weekMatch) {
            const weekKey = weekMatch[1].replace("-W", "-W");
            weekKeys.push(weekKey);
        }
        // Range week file
        const rangeMatch = fileName.match(rangePattern);
        if (rangeMatch) {
            const startWeekKey = rangeMatch[1].replace("-W", "-W");
            const endWeekKey = rangeMatch[2].replace("-W", "-W");
            // For range events, we need to get all weeks in the range
            // Parse dates from week keys
            const startYear = parseInt(startWeekKey.split("-W")[0]);
            const startWeek = parseInt(startWeekKey.split("-W")[1]);
            const endYear = parseInt(endWeekKey.split("-W")[0]);
            const endWeek = parseInt(endWeekKey.split("-W")[1]);
            // Create actual dates
            const startDate = new Date(startYear, 0, 1);
            startDate.setDate(startDate.getDate() + (startWeek - 1) * 7);
            const endDate = new Date(endYear, 0, 1);
            endDate.setDate(endDate.getDate() + (endWeek - 1) * 7 + 6);
            // Get all week keys in the range
            weekKeys = this.getWeekKeysBetweenDates(startDate, endDate);
        }
        // If no matching week keys found, exit
        if (weekKeys.length === 0)
            return;
        // Check each of our event collections and remove matching events
        let needsSave = false;
        // Helper function to filter events
        const filterEvents = (events) => {
            return events.filter((eventData) => {
                const parts = eventData.split(":");
                // Single event (format: weekKey:description)
                if (parts.length === 2) {
                    return !weekKeys.includes(parts[0]);
                }
                // Range event (format: startWeekKey:endWeekKey:description)
                if (parts.length === 3) {
                    const [startKey, endKey] = parts;
                    // Skip if either the start or end key matches one of our weeks
                    return !(weekKeys.includes(startKey) || weekKeys.includes(endKey));
                }
                return true; // Keep any event we don't understand
            });
        };
        // Filter standard event types
        const newGreenEvents = filterEvents(this.settings.greenEvents);
        if (newGreenEvents.length !== this.settings.greenEvents.length) {
            this.settings.greenEvents = newGreenEvents;
            needsSave = true;
        }
        const newBlueEvents = filterEvents(this.settings.blueEvents);
        if (newBlueEvents.length !== this.settings.blueEvents.length) {
            this.settings.blueEvents = newBlueEvents;
            needsSave = true;
        }
        const newPinkEvents = filterEvents(this.settings.pinkEvents);
        if (newPinkEvents.length !== this.settings.pinkEvents.length) {
            this.settings.pinkEvents = newPinkEvents;
            needsSave = true;
        }
        const newPurpleEvents = filterEvents(this.settings.purpleEvents);
        if (newPurpleEvents.length !== this.settings.purpleEvents.length) {
            this.settings.purpleEvents = newPurpleEvents;
            needsSave = true;
        }
        // Filter custom events
        if (this.settings.customEventTypes && this.settings.customEvents) {
            for (const type of this.settings.customEventTypes) {
                if (this.settings.customEvents[type.name]) {
                    const newCustomEvents = filterEvents(this.settings.customEvents[type.name]);
                    if (newCustomEvents.length !==
                        this.settings.customEvents[type.name].length) {
                        this.settings.customEvents[type.name] = newCustomEvents;
                        needsSave = true;
                    }
                }
            }
        }
        // If we made changes, save settings and refresh views
        if (needsSave) {
            await this.saveSettings();
            // Refresh all timeline views
            this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
                const view = leaf.view;
                view.renderView();
            });
            new obsidian.Notice(`Event removed from timeline grid`);
        }
        else {
            // Weekly‐note file was deleted (no settings event removed) — still need to repaint
            this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
                const view = leaf.view;
                view.renderView();
            });
        }
    }
    /**
     * Get a dedicated leaf for Chronica operations
     * @param createIfNeeded - Whether to create a new leaf if none exists
     * @returns A workspace leaf specifically for Chronica
     */
    getChronicaLeaf(createIfNeeded = true) {
        // First, check for existing Chronica views
        const leaves = this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE);
        if (leaves.length > 0) {
            // Use an existing Chronica leaf
            return leaves[0];
        }
        // If no leaf exists and we're asked to create one
        if (createIfNeeded) {
            // Create a new leaf in a split
            return this.app.workspace.getLeaf("split", "vertical");
        }
        return null;
    }
    /**
     * Safely open a file in a Chronica-specific leaf
     * @param file - File to open
     */
    async safelyOpenFile(file) {
        const leaf = this.getChronicaLeaf();
        if (leaf) {
            await leaf.openFile(file);
            this.app.workspace.revealLeaf(leaf);
        }
    }
    /**
     * Track potential sync operations to prevent interference
     */
    isSyncOperation = false;
    syncOperationTimer = null;
    /**
     * Register a file event as a potential sync operation
     */
    registerPotentialSyncOperation() {
        // Clear existing timer
        if (this.syncOperationTimer) {
            clearTimeout(this.syncOperationTimer);
        }
        // Mark as being in a sync operation
        this.isSyncOperation = true;
        // Reset after 5 seconds of no file events
        this.syncOperationTimer = setTimeout(() => {
            this.isSyncOperation = false;
            this.syncOperationTimer = null;
        }, 5000);
    }
}
// -----------------------------------------------------------------------
// EVENT MODAL CLASS
// -----------------------------------------------------------------------
/**
 * Modal dialog for adding life events to the timeline
 */
class ChronosEventModal extends obsidian.Modal {
    /** Reference to the main plugin */
    plugin;
    /** Selected date/week (YYYY-WXX format) */
    selectedDate = "";
    /** Selected end date for range (YYYY-WXX format) */
    selectedEndDate = "";
    /** Flag to indicate if using a date range */
    isDateRange = false;
    /** Selected color for the event */
    selectedColor = "#4CAF50";
    /** Description of the event */
    eventDescription = "";
    /** Name of the event */
    eventName = "";
    /** Currently selected date input field reference */
    singleDateInput;
    /** Start date input field reference */
    startDateInput;
    /** End date input field reference */
    endDateInput;
    /** Currently selected event type */
    selectedEventType = "Major Life";
    /** Name for custom event type */
    customEventName = "";
    /** Flag if custom type is selected */
    isCustomType = false;
    /**
     * Create a new event modal
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     * @param preselectedDate - Optional date to preselect
     */
    constructor(app, plugin, preselectedDate = null) {
        super(app);
        this.plugin = plugin;
        if (preselectedDate) {
            if (preselectedDate.includes("W")) {
                this.selectedDate = preselectedDate;
            }
            else {
                const date = new Date(preselectedDate);
                if (!isNaN(date.getTime())) {
                    this.selectedDate = plugin.getWeekKeyFromDate(date);
                }
            }
        }
    }
    /**
     * Convert a week key (YYYY-WXX) to an approximate date (YYYY-MM-DD)
     * @param weekKey - Week key to convert
     * @returns Date string in YYYY-MM-DD format
     */
    convertWeekToDate(weekKey) {
        const parts = weekKey.split("-W");
        if (parts.length !== 2)
            return "";
        const year = parseInt(parts[0]);
        const week = parseInt(parts[1]);
        const date = new Date(year, 0, 1);
        const dayOfWeek = date.getDay();
        let daysToAdd = (week - 1) * 7;
        if (dayOfWeek <= 4) {
            daysToAdd += 1 - dayOfWeek;
        }
        else {
            daysToAdd += 8 - dayOfWeek;
        }
        date.setDate(date.getDate() + daysToAdd);
        return date.toISOString().split("T")[0];
    }
    /**
     * Build the modal UI when opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Add Life Event" });
        // Date picker section
        const dateContainer = contentEl.createDiv({
            cls: "chronica-date-picker-container",
        });
        dateContainer.createEl("h3", { text: "Select Date" });
        // Add an option to toggle between single date and date range
        const dateTypeContainer = dateContainer.createDiv({
            cls: "date-type-selector",
        });
        const singleDateOption = dateTypeContainer.createEl("label", {
            cls: "date-option",
        });
        const singleDateRadio = singleDateOption.createEl("input", {
            type: "radio",
            attr: { name: "date-type", value: "single" },
        });
        singleDateRadio.checked = true;
        singleDateOption.createEl("span", { text: "Single Date" });
        const rangeDateOption = dateTypeContainer.createEl("label", {
            cls: "date-option",
        });
        const rangeDateRadio = rangeDateOption.createEl("input", {
            type: "radio",
            attr: { name: "date-type", value: "range" },
        });
        rangeDateOption.createEl("span", { text: "Date Range" });
        // Container for single date input
        const singleDateContainer = contentEl.createDiv({
            cls: "single-date-container",
        });
        const singleDateSetting = new obsidian.Setting(singleDateContainer)
            .setName("Date")
            .setDesc("Enter the exact date of the event");
        this.singleDateInput = singleDateSetting.controlEl.createEl("input", {
            type: "date",
            value: this.selectedDate
                ? this.convertWeekToDate(this.selectedDate)
                : new Date().toISOString().split("T")[0],
        });
        this.singleDateInput.addEventListener("change", () => {
            const specificDate = this.singleDateInput.value;
            if (specificDate) {
                const date = new Date(specificDate);
                this.selectedDate = this.plugin.getWeekKeyFromDate(date);
                // If using date range, initialize end date to same as start if not set
                if (this.isDateRange && !this.endDateInput.value) {
                    this.endDateInput.value = specificDate;
                    this.selectedEndDate = this.selectedDate;
                }
            }
        });
        // Container for date range inputs
        const rangeDateContainer = contentEl.createDiv({
            cls: "range-date-container",
        });
        rangeDateContainer.style.display = "none";
        const startDateSetting = new obsidian.Setting(rangeDateContainer)
            .setName("Start Date")
            .setDesc("Enter the first date of the event range");
        this.startDateInput = startDateSetting.controlEl.createEl("input", {
            type: "date",
            value: this.selectedDate
                ? this.convertWeekToDate(this.selectedDate)
                : new Date().toISOString().split("T")[0],
        });
        this.startDateInput.addEventListener("change", () => {
            const specificDate = this.startDateInput.value;
            if (specificDate) {
                const date = new Date(specificDate);
                this.selectedDate = this.plugin.getWeekKeyFromDate(date);
            }
        });
        const endDateSetting = new obsidian.Setting(rangeDateContainer)
            .setName("End Date")
            .setDesc("Enter the last date of the event range");
        this.endDateInput = endDateSetting.controlEl.createEl("input", {
            type: "date",
            value: this.selectedEndDate
                ? this.convertWeekToDate(this.selectedEndDate)
                : this.startDateInput.value,
        });
        this.endDateInput.addEventListener("change", () => {
            const specificDate = this.endDateInput.value;
            if (specificDate) {
                const date = new Date(specificDate);
                this.selectedEndDate = this.plugin.getWeekKeyFromDate(date);
            }
        });
        // Add listeners to toggle between single date and range inputs
        singleDateRadio.addEventListener("change", () => {
            if (singleDateRadio.checked) {
                this.isDateRange = false;
                singleDateContainer.style.display = "block";
                rangeDateContainer.style.display = "none";
            }
        });
        rangeDateRadio.addEventListener("change", () => {
            if (rangeDateRadio.checked) {
                this.isDateRange = true;
                singleDateContainer.style.display = "none";
                rangeDateContainer.style.display = "block";
            }
        });
        contentEl.appendChild(singleDateContainer);
        contentEl.appendChild(rangeDateContainer);
        contentEl.createEl("small", {
            text: "Select the date(s) of your event. The system determines the week(s) automatically.",
            cls: "chronica-helper-text",
        });
        if (this.selectedDate) {
            contentEl.createEl("p", {
                text: this.isDateRange
                    ? `This event spans from week ${this.selectedDate} to ${this.selectedEndDate || this.selectedDate}`
                    : `This date falls in week: ${this.selectedDate}`,
            });
        }
        // Event name field - This should be OUTSIDE of any conditional blocks
        new obsidian.Setting(contentEl)
            .setName("Event Name")
            .setDesc("Short title for this event")
            .addText((text) => text.setPlaceholder("Event name").onChange((value) => {
            this.eventName = value;
        }));
        // Event description field
        new obsidian.Setting(contentEl)
            .setName("Description")
            .setDesc("Brief description of this event")
            .addText((text) => text.setPlaceholder("Event description").onChange((value) => {
            this.eventDescription = value;
        }));
        // Event Type Selection using radio buttons
        const eventTypeContainer = contentEl.createDiv();
        eventTypeContainer.createEl("h3", { text: "Event Type" });
        const presetTypes = [
            { name: "Major Life", color: "#4CAF50" },
            { name: "Travel", color: "#2196F3" },
            { name: "Relationship", color: "#E91E63" },
            { name: "Education/Career", color: "#D2B55B" },
        ];
        const typeSettingContainer = new obsidian.Setting(contentEl)
            .setName("Select Event Type")
            .setDesc("Choose a preset type or create your own");
        const radioContainer = typeSettingContainer.controlEl.createDiv({
            cls: "chronica-radio-container",
        });
        // Create radio buttons for preset event types
        for (const type of presetTypes) {
            const radioLabel = radioContainer.createEl("label", {
                cls: "chronica-radio-label",
            });
            const radioBtn = radioLabel.createEl("input");
            radioBtn.type = "radio";
            radioBtn.name = "eventType";
            radioBtn.value = type.name;
            if (type.name === this.selectedEventType) {
                radioBtn.checked = true;
            }
            const colorBox = radioLabel.createEl("span", {
                cls: "chronica-color-box",
            });
            colorBox.style.backgroundColor = type.color;
            radioLabel.createEl("span", { text: type.name });
            radioBtn.addEventListener("change", () => {
                if (radioBtn.checked) {
                    this.selectedEventType = type.name;
                    this.selectedColor = type.color;
                    this.isCustomType = false;
                    this.updateCustomTypeVisibility(contentEl, false);
                }
            });
        }
        // Custom event type option
        const customLabel = radioContainer.createEl("label", {
            cls: "chronica-radio-label",
        });
        const customRadio = customLabel.createEl("input");
        customRadio.type = "radio";
        customRadio.name = "eventType";
        customRadio.value = "custom";
        customLabel.createEl("span", { text: "Custom Type" });
        customRadio.addEventListener("change", () => {
            if (customRadio.checked) {
                this.isCustomType = true;
                this.updateCustomTypeVisibility(contentEl, true);
            }
        });
        // Custom type settings (initially hidden)
        const customTypeSettings = contentEl.createDiv({
            cls: "chronica-custom-type-settings",
        });
        customTypeSettings.style.display = "none";
        new obsidian.Setting(customTypeSettings)
            .setName("Custom Type Name")
            .setDesc("Enter a name for your custom event type")
            .addText((text) => text.setPlaceholder("Type name").onChange((value) => {
            this.customEventName = value;
        }));
        new obsidian.Setting(customTypeSettings)
            .setName("Custom Color")
            .setDesc("Select a color for this event type")
            .addColorPicker((picker) => {
            picker.setValue("#FF9800").onChange((value) => {
                this.selectedColor = value;
            });
            this.selectedColor = "#FF9800";
        });
        // Append custom settings to content
        contentEl.appendChild(customTypeSettings);
        // Save button
        new obsidian.Setting(contentEl).addButton((btn) => btn
            .setButtonText("Save Event")
            .setCta()
            .onClick(() => {
            this.saveEvent();
        }));
    }
    /**
     * Show or hide custom type settings
     * @param contentEl - Modal content element
     * @param show - Whether to show or hide settings
     */
    updateCustomTypeVisibility(contentEl, show) {
        const customSettings = contentEl.querySelector(".chronica-custom-type-settings");
        if (customSettings) {
            customSettings.style.display = show ? "block" : "none";
        }
    }
    /**
     * Save the event to settings and create a note
     */
    async saveEvent() {
        // Validate inputs
        if (!this.selectedDate && this.startDateInput) {
            new obsidian.Notice("Please select a date");
            return;
        }
        if (!this.eventName) {
            new obsidian.Notice("Please add an event name");
            return;
        }
        // For date range, validate end date
        if (this.isDateRange &&
            (!this.selectedEndDate || !this.endDateInput?.value)) {
            new obsidian.Notice("Please select an end date for the range");
            return;
        }
        // Handle adding custom event type if needed
        if (this.isCustomType && this.customEventName) {
            const existingIndex = this.plugin.settings.customEventTypes.findIndex((type) => type.name === this.customEventName);
            if (existingIndex === -1) {
                this.plugin.settings.customEventTypes.push({
                    name: this.customEventName,
                    color: this.selectedColor,
                });
                this.plugin.settings.customEvents[this.customEventName] = [];
            }
            this.selectedEventType = this.customEventName;
        }
        // If using date range, create events for all weeks in the range
        if (this.isDateRange && this.selectedEndDate) {
            // Get start and end dates
            const startDate = new Date(this.startDateInput.value);
            const endDate = new Date(this.endDateInput.value);
            // Get all week keys in the range
            const weekKeys = this.plugin.getWeekKeysBetweenDates(startDate, endDate);
            // Create filename for the note (use the whole range)
            const startWeekKey = this.plugin.getWeekKeyFromDate(startDate);
            const endWeekKey = this.plugin.getWeekKeyFromDate(endDate);
            const fileName = `${startWeekKey.replace("W", "-W")}_to_${endWeekKey.replace("W", "-W")}.md`;
            // Format date range event data with range markers
            const eventData = `${startWeekKey}:${endWeekKey}:${this.eventDescription}`;
            // Add event to appropriate collection
            this.addEventToCollection(eventData);
            // Create a note for the event (for the range)
            this.createEventNote(fileName, startDate, endDate);
            // NEW: Add metadata to the first week's note
            const metadata = {
                event: this.eventName,
                name: this.eventName,
                description: this.eventDescription,
                type: this.selectedEventType,
                color: this.selectedColor,
                startDate: startDate.toISOString().split("T")[0],
                endDate: endDate.toISOString().split("T")[0],
            };
            await this.plugin.updateEventInNote(startWeekKey, metadata);
            // Save settings
            this.plugin.saveSettings().then(() => {
                new obsidian.Notice(`Event added: ${this.eventDescription} (${weekKeys.length} weeks)`);
                this.close();
                this.refreshViews();
            });
        }
        else {
            // Handle single date event (original functionality)
            const eventDate = new Date(this.singleDateInput.value);
            const weekKey = this.plugin.getWeekKeyFromDate(eventDate);
            const eventData = `${weekKey}:${this.eventDescription}`;
            const fileName = `${weekKey.replace("W", "-W")}.md`;
            // Add to existing event collections
            this.addEventToCollection(eventData);
            // Create a note for the event
            this.createEventNote(fileName, eventDate);
            // NEW: Add metadata to the week note
            const metadata = {
                event: this.eventName,
                name: this.eventName,
                description: this.eventDescription,
                type: this.selectedEventType,
                color: this.selectedColor,
                startDate: eventDate.toISOString().split("T")[0],
            };
            await this.plugin.updateEventInNote(weekKey, metadata);
            this.plugin.saveSettings().then(() => {
                new obsidian.Notice(`Event added: ${this.eventDescription}`);
                this.close();
                this.refreshViews();
            });
        }
    }
    /**
     * Add event to the appropriate collection based on event type
     * @param eventData - Event data string
     */
    addEventToCollection(eventData) {
        switch (this.selectedEventType) {
            case "Major Life":
                this.plugin.settings.greenEvents.push(eventData);
                break;
            case "Travel":
                this.plugin.settings.blueEvents.push(eventData);
                break;
            case "Relationship":
                this.plugin.settings.pinkEvents.push(eventData);
                break;
            case "Education/Career":
                this.plugin.settings.purpleEvents.push(eventData);
                break;
            default:
                // Custom event type
                if (!this.plugin.settings.customEvents[this.selectedEventType]) {
                    this.plugin.settings.customEvents[this.selectedEventType] = [];
                }
                this.plugin.settings.customEvents[this.selectedEventType].push(eventData);
        }
    }
    /**
     * Create a note file for the event
     * @param fileName - Name of the file
     * @param startDate - Start date of the event
     * @param endDate - Optional end date for range events
     */
    async createEventNote(fileName, startDate, endDate) {
        const fullPath = this.plugin.getFullPath(fileName);
        const fileExists = this.plugin.app.vault.getAbstractFileByPath(fullPath) instanceof obsidian.TFile;
        if (!fileExists) {
            // Create folder if needed
            if (this.plugin.settings.notesFolder &&
                this.plugin.settings.notesFolder.trim() !== "") {
                try {
                    const folderExists = this.app.vault.getAbstractFileByPath(this.plugin.settings.notesFolder);
                    if (!folderExists) {
                        await this.app.vault.createFolder(this.plugin.settings.notesFolder);
                    }
                }
                catch (err) {
                    console.log("Error checking/creating folder:", err);
                }
            }
            // Create event note file with frontmatter and content
            let content = "";
            if (endDate) {
                // Range event
                const startDateStr = startDate.toISOString().split("T")[0];
                const endDateStr = endDate.toISOString().split("T")[0];
                // Get week keys for title
                const startWeekKey = this.plugin.getWeekKeyFromDate(startDate);
                const endWeekKey = this.plugin.getWeekKeyFromDate(endDate);
                const startWeekDisplayName = startWeekKey.replace("W", "-W");
                const endWeekDisplayName = endWeekKey.replace("W", "-W");
                // Add frontmatter
                const metadata = {
                    event: this.eventName,
                    name: this.eventName,
                    description: this.eventDescription,
                    type: this.selectedEventType,
                    color: this.selectedColor,
                    startDate: startDateStr,
                    endDate: endDateStr,
                };
                content = this.plugin.formatFrontmatter(metadata);
                // Add note content with updated title
                content += `# ${startWeekDisplayName}_to_${endWeekDisplayName} (${this.eventName})\n\nStart Date: ${startDateStr}\nEnd Date: ${endDateStr}\nType: ${this.selectedEventType}\nDescription: ${this.eventDescription}\n\n## Notes\n\n`;
            }
            else {
                // Single date event
                const dateStr = startDate.toISOString().split("T")[0];
                // Get week key for title
                const weekKey = this.plugin.getWeekKeyFromDate(startDate);
                const weekDisplayName = weekKey.replace("W", "-W");
                // Add frontmatter
                const metadata = {
                    event: this.eventName,
                    name: this.eventName,
                    description: this.eventDescription,
                    type: this.selectedEventType,
                    color: this.selectedColor,
                    startDate: dateStr,
                };
                content = this.plugin.formatFrontmatter(metadata);
                // Add note content with updated title
                content += `# ${weekDisplayName} (${this.eventName})\n\nDate: ${dateStr}\nType: ${this.selectedEventType}\nDescription: ${this.eventDescription}\n\n## Notes\n\n`;
            }
            await this.app.vault.create(fullPath, content);
        }
    }
    /**
     * Refresh all timeline views
     */
    refreshViews() {
        this.plugin.app.workspace
            .getLeavesOfType(TIMELINE_VIEW_TYPE)
            .forEach((leaf) => {
            const view = leaf.view;
            view.renderView();
        });
    }
    /**
     * Clean up on modal close
     */
    onClose() {
        this.contentEl.empty();
    }
}
// -----------------------------------------------------------------------
// TIMELINE VIEW CLASS
// -----------------------------------------------------------------------
/**
 * Main timeline view that shows the life grid and events
 */
class ChronosTimelineView extends obsidian.ItemView {
    /** Reference to the main plugin */
    plugin;
    /** Track sidebar open/closed state */
    isSidebarOpen;
    isStatsOpen;
    isNarrowViewport() {
        return window.innerWidth <= 768;
    }
    constructor(leaf, plugin) {
        super(leaf);
        this.plugin = plugin;
        this.isSidebarOpen = this.plugin.settings.isSidebarOpen;
        this.isStatsOpen = this.plugin.settings.isStatsOpen;
        // Initialize CSS variables for stats panel
        document.documentElement.style.setProperty("--stats-panel-height", `${this.plugin.settings.statsPanelHeight}px`);
        document.documentElement.style.setProperty("--stats-panel-width", `${this.plugin.settings.statsPanelWidth}px`);
        this.registerDomEvent(window, "resize", () => {
            // Reapply layout rules whenever window size changes
            this.updateStatsPanelLayout();
        });
    }
    /**
     * Setup the horizontal resize functionality for the stats panel
     * @param leftHandle - Left handle element for dragging
     * @param rightHandle - Right handle element for dragging
     * @param statsPanel - Panel to resize
     */
    setupStatsPanelHorizontalResize(leftHandle, rightHandle, statsPanel) {
        let startX = 0;
        let startWidth = 0;
        // Left handle drag (decreases width)
        const onLeftMouseDown = (e) => {
            if (e.button !== 0)
                return;
            e.preventDefault();
            startWidth = this.plugin.settings.statsPanelWidth;
            startX = e.clientX;
            document.addEventListener("mousemove", onLeftMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        const onLeftMouseMove = (e) => {
            const deltaX = startX - e.clientX;
            const newWidth = Math.max(400, Math.min(1200, startWidth + deltaX));
            document.documentElement.style.setProperty("--stats-panel-width", `${newWidth}px`);
            statsPanel.style.width = `${newWidth}px`;
            statsPanel.style.minWidth = `${newWidth}px`;
            statsPanel.style.maxWidth = `${newWidth}px`;
            this.plugin.settings.statsPanelWidth = newWidth;
        };
        // Right handle drag (increases width)
        const onRightMouseDown = (e) => {
            if (e.button !== 0)
                return;
            e.preventDefault();
            startWidth = this.plugin.settings.statsPanelWidth;
            startX = e.clientX;
            document.addEventListener("mousemove", onRightMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        const onRightMouseMove = (e) => {
            const deltaX = e.clientX - startX;
            const newWidth = Math.max(400, Math.min(1200, startWidth + deltaX));
            document.documentElement.style.setProperty("--stats-panel-width", `${newWidth}px`);
            statsPanel.style.width = `${newWidth}px`;
            statsPanel.style.minWidth = `${newWidth}px`;
            statsPanel.style.maxWidth = `${newWidth}px`;
            this.plugin.settings.statsPanelWidth = newWidth;
        };
        const onMouseUp = () => {
            document.removeEventListener("mousemove", onLeftMouseMove);
            document.removeEventListener("mousemove", onRightMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            this.plugin.saveSettings();
        };
        leftHandle.addEventListener("mousedown", onLeftMouseDown);
        rightHandle.addEventListener("mousedown", onRightMouseDown);
    }
    setupStatsPanelHorizontalDrag(headerEl, statsPanel, statsHandle) {
        let startX = 0;
        let startOffset = 0;
        const onMouseDown = (e) => {
            // Only respond to left mouse button
            if (e.button !== 0)
                return;
            // Skip if clicked on a button or other control
            if (e.target.tagName === "BUTTON" ||
                e.target.closest(".chronica-stats-tab") ||
                e.target.closest(".chronica-stats-close")) {
                return;
            }
            e.preventDefault();
            // Get current horizontal offset
            startOffset = this.plugin.settings.statsPanelHorizontalOffset || 0;
            startX = e.clientX;
            // Add event listeners
            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        const onMouseMove = (e) => {
            // Calculate horizontal change
            const deltaX = e.clientX - startX;
            // Calculate boundaries
            const windowWidth = window.innerWidth;
            const panelWidth = statsPanel.getBoundingClientRect().width;
            const maxOffset = (windowWidth - panelWidth) / 2;
            const newOffset = Math.max(-maxOffset, Math.min(maxOffset, startOffset + deltaX));
            // Apply horizontal offset to panel and handle
            statsPanel.style.transform = `translateX(calc(-50% + ${newOffset}px))`;
            statsHandle.style.transform = `translateX(calc(-50% + ${newOffset}px))`;
            // Update setting (but don't save yet)
            this.plugin.settings.statsPanelHorizontalOffset = newOffset;
        };
        const onMouseUp = () => {
            // Remove event listeners
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            // Save settings
            this.plugin.saveSettings();
        };
        // Add initial event listener
        headerEl.addEventListener("mousedown", onMouseDown);
    }
    /**
     * Setup left and right resize handles for the stats panel
     * @param statsPanel - Panel to resize
     */
    setupStatsPanelWidthResize(statsPanel) {
        // Create left and right resize handles
        const leftHandle = statsPanel.createEl("div", {
            cls: "chronica-stats-left-handle",
        });
        const rightHandle = statsPanel.createEl("div", {
            cls: "chronica-stats-right-handle",
        });
        let startX = 0;
        let startWidth = 0;
        // Left handle drag (decreases width)
        const onLeftMouseDown = (e) => {
            if (e.button !== 0)
                return;
            e.preventDefault();
            startWidth = this.plugin.settings.statsPanelWidth;
            startX = e.clientX;
            document.addEventListener("mousemove", onLeftMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        const onLeftMouseMove = (e) => {
            const deltaX = startX - e.clientX;
            const newWidth = Math.max(400, Math.min(1200, startWidth + deltaX));
            document.documentElement.style.setProperty("--stats-panel-width", `${newWidth}px`);
            statsPanel.style.width = `${newWidth}px`;
            this.plugin.settings.statsPanelWidth = newWidth;
        };
        // Right handle drag (increases width)
        const onRightMouseDown = (e) => {
            if (e.button !== 0)
                return;
            e.preventDefault();
            startWidth = this.plugin.settings.statsPanelWidth;
            startX = e.clientX;
            document.addEventListener("mousemove", onRightMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        const onRightMouseMove = (e) => {
            const deltaX = e.clientX - startX;
            const newWidth = Math.max(400, Math.min(1200, startWidth + deltaX));
            document.documentElement.style.setProperty("--stats-panel-width", `${newWidth}px`);
            statsPanel.style.width = `${newWidth}px`;
            this.plugin.settings.statsPanelWidth = newWidth;
        };
        const onMouseUp = () => {
            document.removeEventListener("mousemove", onLeftMouseMove);
            document.removeEventListener("mousemove", onRightMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            this.plugin.saveSettings();
        };
        leftHandle.addEventListener("mousedown", onLeftMouseDown);
        rightHandle.addEventListener("mousedown", onRightMouseDown);
    }
    /**
     * Get the unique view type
     */
    getViewType() {
        return TIMELINE_VIEW_TYPE;
    }
    /**
     * Get display name for the view
     */
    getDisplayText() {
        return "Chronica - Life in Frames";
    }
    /**
     * Get icon for the view
     */
    getIcon() {
        return "calendar-days";
    }
    /**
     * Initialize the view when opened
     */
    async onOpen() {
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
        contentEl.addClass("chronica-timeline-container");
        // Set initial CSS variables - this should be done regardless of panel state
        document.documentElement.style.setProperty("--stats-panel-height", `${this.plugin.settings.statsPanelHeight}px`);
        // Additional setup only if stats panel is open
        if (this.isStatsOpen) {
            // Force content area padding update
            const contentArea = this.containerEl.querySelector(".chronica-content-area");
            if (contentArea) {
                contentArea.classList.add("stats-expanded");
            }
        }
        this.renderView();
        if (this.plugin.settings.defaultFitToScreen) {
            // Use setTimeout to ensure the grid is fully rendered before fitting
            setTimeout(() => {
                this.fitToScreen();
            }, 100);
        }
    }
    /**
     * Clean up when view is closed
     */
    async onClose() {
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
    }
    /**
     * Render the timeline view with all components
     */
    renderView() {
        // Clear content
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
        // Create main container with flexbox layout
        const mainContainer = contentEl.createEl("div", {
            cls: "chronica-main-container",
        });
        // Create sidebar
        const sidebarEl = mainContainer.createEl("div", {
            cls: `chronica-sidebar ${this.isSidebarOpen ? "expanded" : "collapsed"}`,
        });
        // Add sidebar header with title and toggle
        const sidebarHeader = sidebarEl.createEl("div", {
            cls: "chronica-sidebar-header",
        });
        // Create title in sidebar header
        sidebarHeader.createEl("div", {
            cls: "chronica-title",
            text: "life in frames",
        });
        // Create sidebar toggle as part of the sidebar itself
        const sidebarToggle = sidebarHeader.createEl("button", {
            cls: "chronica-sidebar-toggle",
            attr: {
                title: this.isSidebarOpen ? "Collapse Sidebar" : "Expand Sidebar",
            },
        });
        sidebarToggle.innerHTML = this.isSidebarOpen
            ? `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>`;
        sidebarToggle.addEventListener("click", () => {
            this.isSidebarOpen = !this.isSidebarOpen;
            // Save state to plugin settings
            this.plugin.settings.isSidebarOpen = this.isSidebarOpen;
            this.plugin.saveSettings();
            // Update UI
            sidebarEl.classList.toggle("collapsed", !this.isSidebarOpen);
            sidebarEl.classList.toggle("expanded", this.isSidebarOpen);
            // Update toggle icon
            sidebarToggle.innerHTML = this.isSidebarOpen
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>`;
            sidebarToggle.setAttribute("title", this.isSidebarOpen ? "Collapse Sidebar" : "Expand Sidebar");
            // Toggle visibility of the collapsed toggle button
            if (collapsedToggle) {
                collapsedToggle.style.display = this.isSidebarOpen ? "none" : "block";
            }
            this.updateStatsPanelLayout();
        });
        // Controls section
        const controlsSection = sidebarEl.createEl("div", {
            cls: "chronica-sidebar-section",
        });
        controlsSection.createEl("h3", { text: "CONTROLS", cls: "section-header" });
        const controlsContainer = controlsSection.createEl("div", {
            cls: "chronica-controls",
        });
        // Plan future event button
        const planEventBtn = controlsContainer.createEl("button", {
            text: "Plan Event",
            cls: "chronica-btn chronica-btn-primary",
        });
        planEventBtn.addEventListener("click", () => {
            this.showAddEventModal();
        });
        // Manage event types button
        const manageTypesBtn = controlsContainer.createEl("button", {
            text: "Manage Event Types",
            cls: "chronica-btn chronica-btn-primary", // Same styling as Plan Event
        });
        manageTypesBtn.addEventListener("click", () => {
            const modal = new ManageEventTypesModal(this.app, this.plugin);
            modal.open();
        });
        // Visualization controls section
        const visualSection = sidebarEl.createEl("div", {
            cls: "chronica-sidebar-section",
        });
        visualSection.createEl("h3", {
            text: "VIEW OPTIONS",
            cls: "section-header",
        });
        const visualContainer = visualSection.createEl("div", {
            cls: "chronica-visual-controls",
        });
        // Zoom controls with 3-button layout
        const zoomControlsDiv = visualContainer.createEl("div", {
            cls: "chronica-zoom-controls",
        });
        // Zoom out button with SVG icon
        const zoomOutBtn = zoomControlsDiv.createEl("button", {
            cls: "chronica-btn chronica-zoom-button",
            attr: { title: "Zoom Out" },
        });
        zoomOutBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      <line x1="8" y1="11" x2="14" y2="11"></line>
    </svg>`;
        zoomOutBtn.addEventListener("click", () => {
            this.zoomOut();
        });
        // Add zoom level indicator
        const zoomInput = zoomControlsDiv.createEl("input", {
            cls: "chronica-zoom-input",
            attr: {
                type: "number",
                min: "10",
                max: "500",
                step: "1",
                value: `${Math.round(this.plugin.settings.zoomLevel * 100)}`,
                title: "Enter zoom % and press ↵",
            },
        });
        zoomInput.addEventListener("change", async (e) => {
            const input = e.target;
            let val = parseInt(input.value, 10);
            if (isNaN(val))
                val = Math.round(this.plugin.settings.zoomLevel * 100);
            val = Math.min(500, Math.max(10, val));
            this.plugin.settings.zoomLevel = val / 100;
            await this.plugin.saveSettings();
            this.updateZoomLevel();
            // reflect any clamping back
            input.value = `${Math.round(this.plugin.settings.zoomLevel * 100)}`;
        });
        // Zoom in button with SVG icon
        const zoomInBtn = zoomControlsDiv.createEl("button", {
            cls: "chronica-btn chronica-zoom-button",
            attr: { title: "Zoom In" },
        });
        zoomInBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="11" cy="11" r="8"></circle>
      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      <line x1="11" y1="8" x2="11" y2="14"></line>
      <line x1="8" y1="11" x2="14" y2="11"></line>
    </svg>`;
        zoomInBtn.addEventListener("click", () => {
            this.zoomIn();
        });
        // Fit to screen button
        const fitToScreenBtn = visualContainer.createEl("button", {
            cls: "chronica-btn chronica-fit-to-screen",
            text: "Fit to Screen",
            attr: { title: "Automatically adjust zoom to fit entire grid on screen" },
        });
        fitToScreenBtn.addEventListener("click", () => {
            this.fitToScreen();
        });
        // ── Cell Shape Dropdown ──
        visualContainer.createEl("div", {
            cls: "section-header",
            text: "Cell Shape",
        });
        // Select
        const shapeSelect = visualContainer.createEl("select", {
            cls: "chronica-select",
        });
        ["square", "circle", "diamond"].forEach((opt) => {
            const option = shapeSelect.createEl("option", {
                attr: { value: opt },
                text: opt.charAt(0).toUpperCase() + opt.slice(1),
            });
            if (this.plugin.settings.cellShape === opt) {
                option.selected = true;
            }
        });
        shapeSelect.addEventListener("change", async () => {
            this.plugin.settings.cellShape = shapeSelect.value;
            await this.plugin.saveSettings();
            // Re-render grid with new shape
            this.updateZoomLevel();
        });
        // ── Grid Orientation Toggle ──
        visualContainer.createEl("div", {
            cls: "section-header",
            text: "Grid Orientation",
        });
        // Orientation toggle button
        const orientationBtn = visualContainer.createEl("button", {
            cls: "chronica-btn chronica-orientation-button",
            text: this.plugin.settings.gridOrientation === "landscape"
                ? "Switch to Portrait"
                : "Switch to Landscape",
            attr: {
                title: this.plugin.settings.gridOrientation === "landscape"
                    ? "Display years as rows, weeks as columns"
                    : "Display years as columns, weeks as rows",
            },
        });
        orientationBtn.addEventListener("click", async () => {
            // Toggle the orientation
            this.plugin.settings.gridOrientation =
                this.plugin.settings.gridOrientation === "landscape"
                    ? "portrait"
                    : "landscape";
            // Save settings
            await this.plugin.saveSettings();
            // Update button text
            orientationBtn.textContent =
                this.plugin.settings.gridOrientation === "landscape"
                    ? "Switch to Portrait"
                    : "Switch to Landscape";
            orientationBtn.setAttribute("title", this.plugin.settings.gridOrientation === "landscape"
                ? "Display years as rows, weeks as columns"
                : "Display years as columns, weeks as rows");
            // Re-render the grid with new orientation
            this.updateZoomLevel();
        });
        // Legend section (vertical)
        const legendSection = sidebarEl.createEl("div", {
            cls: "chronica-sidebar-section",
        });
        legendSection.createEl("h3", { text: "LEGEND", cls: "section-header" });
        const legendEl = legendSection.createEl("div", { cls: "chronica-legend" });
        // Standard event types for legend
        const legendItems = [
            { text: "Major Life Events", color: "#4CAF50" },
            { text: "Travel", color: "#2196F3" },
            { text: "Relationships", color: "#E91E63" },
            { text: "Education/Career", color: "#D2B55B" },
            {
                text: "Upcoming Planned Event",
                color: this.plugin.settings.futureCellColor,
            },
        ];
        // Add standard legend items
        legendItems.forEach((item) => {
            const itemEl = legendEl.createEl("div", { cls: "chronica-legend-item" });
            const colorEl = itemEl.createEl("div", { cls: "chronica-legend-color" });
            colorEl.style.backgroundColor = item.color;
            itemEl.createEl("span", { text: item.text });
        });
        // Render custom event type legends
        if (this.plugin.settings.customEventTypes) {
            this.plugin.settings.customEventTypes.forEach((customType) => {
                const customLegendEl = legendEl.createEl("div", {
                    cls: "chronica-legend-item",
                });
                const customColorEl = customLegendEl.createEl("div", {
                    cls: "chronica-legend-color",
                });
                customColorEl.style.backgroundColor = customType.color;
                customLegendEl.createEl("span", { text: customType.name });
            });
        }
        // Footer in sidebar
        sidebarEl.createEl("div", {
            cls: "chronica-footer",
            text: this.plugin.settings.quote,
        });
        // Create content area
        const contentAreaEl = mainContainer.createEl("div", {
            cls: "chronica-content-area",
        });
        // Calculate basic statistics
        const now = new Date();
        const [year, month, day] = this.plugin.settings.birthday
            .split("-")
            .map(Number);
        const birthdayDate = new Date(year, month - 1, day);
        const ageInWeeks = this.plugin.getFullWeekAge(birthdayDate, now);
        const totalWeeks = this.plugin.settings.lifespan * 52;
        ((ageInWeeks / totalWeeks) * 100).toFixed(1);
        // Count events
        this.plugin.settings.greenEvents.length;
        this.plugin.settings.blueEvents.length;
        this.plugin.settings.pinkEvents.length;
        this.plugin.settings.purpleEvents.length;
        // Calculate custom event counts
        let customEventCount = 0;
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEvents) {
            for (const eventType of this.plugin.settings.customEventTypes) {
                if (this.plugin.settings.customEvents[eventType.name]) {
                    customEventCount +=
                        this.plugin.settings.customEvents[eventType.name].length;
                }
            }
        }
        // Always create collapsed sidebar indicator/toggle (but hide it when sidebar is open)
        const collapsedToggle = contentAreaEl.createEl("button", {
            cls: "chronica-collapsed-toggle",
            attr: { title: "Expand Sidebar" },
        });
        collapsedToggle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>`;
        collapsedToggle.addEventListener("click", () => {
            this.isSidebarOpen = true;
            // Save state to plugin settings
            this.plugin.settings.isSidebarOpen = true;
            this.plugin.saveSettings();
            // Update the view without full re-render
            sidebarEl.classList.remove("collapsed");
            sidebarEl.classList.add("expanded");
            collapsedToggle.style.display = "none";
            // Update sidebar toggle icon
            const sidebarToggle = sidebarEl.querySelector(".chronica-sidebar-toggle");
            if (sidebarToggle) {
                sidebarToggle.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>`;
                sidebarToggle.setAttribute("title", "Collapse Sidebar");
            }
            this.updateStatsPanelLayout();
        });
        // Show/hide the toggle button based on sidebar state
        collapsedToggle.style.display = this.isSidebarOpen ? "none" : "block";
        // Create the view container
        const viewEl = contentAreaEl.createEl("div", { cls: "chronica-view" });
        // Render the weeks grid
        this.renderWeeksGrid(viewEl);
        this.renderStatsPanel(contentAreaEl);
    }
    /**
     * Show modal for adding an event
     */
    showAddEventModal() {
        const modal = new ChronosEventModal(this.app, this.plugin);
        modal.open();
    }
    /**
     * Zoom in the grid view
     */
    zoomIn() {
        // Get the current zoom level
        const currentZoom = this.plugin.settings.zoomLevel;
        // Check if the current zoom is already at a multiple of 0.1
        const isMultipleOfTen = Math.abs(currentZoom * 10 - Math.round(currentZoom * 10)) < 0.001;
        let nextZoom;
        if (isMultipleOfTen) {
            // If already at a multiple of 0.1, increment by 0.1
            nextZoom = currentZoom + 0.1;
        }
        else {
            // Otherwise, go to the next multiple of 0.1
            nextZoom = Math.ceil(currentZoom * 10) / 10;
        }
        // Apply the new zoom level, max 3.0
        this.plugin.settings.zoomLevel = Math.min(3.0, nextZoom);
        this.plugin.saveSettings();
        // Update only the grid and zoom level indicator without full re-render
        this.updateZoomLevel();
    }
    /**
     * Zoom out the grid view
     */
    zoomOut() {
        // Get the current zoom level
        const currentZoom = this.plugin.settings.zoomLevel;
        // Check if the current zoom is already at a multiple of 0.1
        const isMultipleOfTen = Math.abs(currentZoom * 10 - Math.round(currentZoom * 10)) < 0.001;
        let nextZoom;
        if (isMultipleOfTen) {
            // If already at a multiple of 0.1, decrement by 0.1
            nextZoom = currentZoom - 0.1;
        }
        else {
            // Otherwise, go to the previous multiple of 0.1
            nextZoom = Math.floor(currentZoom * 10) / 10;
        }
        // Apply the new zoom level, min 0.1 (10%)
        this.plugin.settings.zoomLevel = Math.max(0.1, nextZoom);
        this.plugin.saveSettings();
        // Update only the grid and zoom level indicator without full re-render
        this.updateZoomLevel();
    }
    isGridFitToScreen() {
        const contentEl = this.containerEl.children[1];
        const contentArea = contentEl.querySelector(".chronica-content-area");
        const viewEl = contentArea.querySelector(".chronica-view");
        if (!viewEl || !contentArea)
            return false;
        // Same math as fitToScreen()
        const cs = getComputedStyle(viewEl);
        const padL = parseInt(cs.paddingLeft) || 0;
        const padR = parseInt(cs.paddingRight) || 0;
        const padT = parseInt(cs.paddingTop) || 0;
        const padB = parseInt(cs.paddingBottom) || 0;
        const availW = viewEl.clientWidth - padL - padR;
        const availH = viewEl.clientHeight - padT - padB;
        const rootStyle = getComputedStyle(document.documentElement);
        const baseSize = parseInt(rootStyle.getPropertyValue("--base-cell-size")) || 16;
        const gap = parseInt(rootStyle.getPropertyValue("--cell-gap")) || 2;
        const years = this.plugin.settings.lifespan;
        const weeks = 52;
        const idealW = (availW - (years - 1) * gap) / years;
        const idealH = (availH - (weeks - 1) * gap) / weeks;
        const idealCell = Math.min(idealW, idealH);
        const idealZoom = idealCell / baseSize;
        return Math.abs(this.plugin.settings.zoomLevel - idealZoom) < 0.01;
    }
    /**
     * Automatically adjust zoom level to fit the entire grid on screen
     */
    // Replace the fitToScreen() function in src/main.ts with this improved version:
    fitToScreen() {
        // Get relevant containers
        const contentEl = this.containerEl.children[1];
        const contentArea = contentEl.querySelector(".chronica-content-area");
        const viewEl = contentArea.querySelector(".chronica-view");
        if (!viewEl || !contentArea)
            return;
        // Get available space (accounting for sidebar and markers)
        const cs = getComputedStyle(viewEl);
        const padL = parseInt(cs.paddingLeft) || 0;
        const padR = parseInt(cs.paddingRight) || 0;
        const padT = parseInt(cs.paddingTop) || 0;
        const padB = parseInt(cs.paddingBottom) || 0;
        // Account for sidebar width
        this.isSidebarOpen ? 240 : 0;
        const availW = viewEl.clientWidth - padL - padR;
        const availH = viewEl.clientHeight - padT - padB;
        // Get grid parameters
        const rootStyle = getComputedStyle(document.documentElement);
        const baseSize = parseInt(rootStyle.getPropertyValue("--base-cell-size")) || 16;
        parseInt(rootStyle.getPropertyValue("--cell-gap")) || 2;
        const years = this.plugin.settings.lifespan;
        const weeks = 52;
        // Calculate optimal cell size
        const targetWidth = availW * 0.95;
        const targetHeight = availH * 0.95;
        const cellW = targetWidth / years;
        const cellH = targetHeight / weeks;
        // Get the smaller dimension to ensure fit
        let idealCellSize = Math.min(cellW, cellH);
        // Enforce minimum size
        idealCellSize = Math.max(idealCellSize, 8);
        // Convert to zoom ratio
        const newZoom = idealCellSize / baseSize;
        // Apply zoom (clamped to reasonable range)
        this.plugin.settings.zoomLevel = Math.max(0.5, Math.min(2.5, newZoom));
        this.plugin.saveSettings();
        // Update zoom
        this.updateZoomLevel();
        // Reset transforms
        const gridEl = viewEl.querySelector(".chronica-grid");
        const decadeMarkers = viewEl.querySelector(".chronica-decade-markers");
        if (gridEl)
            gridEl.style.transform = "";
        if (decadeMarkers)
            decadeMarkers.style.transform = "";
    }
    /**
     * Update zoom-affected elements with adjusted positioning
     */
    updateZoomLevel() {
        // Get the container element
        const contentEl = this.containerEl.children[1];
        // Use a more robust selector to find the zoom level indicator anywhere in the container
        const zoomInput = this.containerEl.querySelector(".chronica-zoom-input");
        if (zoomInput) {
            zoomInput.value = `${Math.round(this.plugin.settings.zoomLevel * 100)}`;
        }
        // Update cell size CSS variable
        const root = document.documentElement;
        const baseSize = parseInt(getComputedStyle(root).getPropertyValue("--base-cell-size")) ||
            16;
        const cellSize = Math.round(baseSize * this.plugin.settings.zoomLevel);
        root.style.setProperty("--cell-size", `${cellSize}px`);
        // Reset transforms before rerendering
        const viewEl = contentEl.querySelector(".chronica-view");
        if (viewEl instanceof HTMLElement) {
            const gridEl = viewEl.querySelector(".chronica-grid");
            const decadeMarkers = viewEl.querySelector(".chronica-decade-markers");
            const verticalMarkers = viewEl.querySelector(".chronica-vertical-markers");
            if (gridEl)
                gridEl.style.transform = "";
            if (decadeMarkers)
                decadeMarkers.style.transform = "";
            if (verticalMarkers)
                verticalMarkers.style.transform = "";
            // Clear the view and re-render
            viewEl.empty();
            this.renderWeeksGrid(viewEl);
        }
    }
    /**
     * Render the main weeks grid visualization
     * @param container - Container to render grid in
     */
    renderWeeksGrid(container) {
        container.empty();
        // Get the CSS variables for positioning and styling
        const root = document.documentElement;
        const baseSize = parseInt(getComputedStyle(root).getPropertyValue("--base-cell-size")) ||
            16;
        const cellSize = Math.round(baseSize * this.plugin.settings.zoomLevel);
        // Apply the zoomed cell size to the CSS variable
        root.style.setProperty("--cell-size", `${cellSize}px`);
        const cellGap = parseInt(getComputedStyle(root).getPropertyValue("--cell-gap")) || 2;
        const leftOffset = parseInt(getComputedStyle(root).getPropertyValue("--left-offset")) || 70;
        const topOffset = parseInt(getComputedStyle(root).getPropertyValue("--top-offset")) || 50;
        const regularGap = cellGap; // Store the regular gap size
        // Create decade markers container (horizontal markers above the grid)
        if (this.plugin.settings.showDecadeMarkers) {
            const isPortrait = this.plugin.settings.gridOrientation === "portrait";
            const decadeMarkersContainer = container.createEl("div", {
                cls: `chronica-decade-markers ${isPortrait ? "portrait-mode" : ""}`,
            });
            if (!isPortrait) {
                decadeMarkersContainer.style.left = `${leftOffset}px`;
            }
            // Add decade markers starting from 10 (skipping 0)
            // Create decade markers container (horizontal markers above the grid)
            if (this.plugin.settings.showDecadeMarkers) {
                const isPortrait = this.plugin.settings.gridOrientation === "portrait";
                const decadeMarkersContainer = container.createEl("div", {
                    cls: `chronica-decade-markers ${isPortrait ? "portrait-mode" : ""}`,
                });
                if (!isPortrait) {
                    decadeMarkersContainer.style.left = `${leftOffset}px`;
                }
                // Add decade markers starting from 10 (skipping 0)
                for (let decade = 10; decade <= this.plugin.settings.lifespan; decade += 10) {
                    const marker = decadeMarkersContainer.createEl("div", {
                        cls: `chronica-decade-marker ${isPortrait ? "portrait-mode" : ""}`,
                        text: decade.toString(),
                    });
                    // Position each decade marker using the calculateYearPosition method
                    marker.style.position = "absolute";
                    // Calculate the position of last year of previous decade (e.g., year 9 for marker "10")
                    const lastYearOfPreviousDecade = decade - 1;
                    // Get position of this year - this will be the position of the column we want to place the marker above
                    const decadePosition = this.plugin.calculateYearPosition(lastYearOfPreviousDecade, cellSize, regularGap);
                    // Position marker at the CENTER of the column, not past it
                    const leftPosition = decadePosition + cellSize / 2;
                    if (isPortrait) {
                        marker.style.top = `${leftPosition}px`;
                        marker.style.left = `${topOffset}px`;
                        marker.style.transform = "translate(-50%, -50%)"; // Keep centered
                    }
                    else {
                        marker.style.left = `${leftPosition}px`;
                        marker.style.top = `${topOffset / 2}px`;
                        marker.style.transform = "translate(-50%, -50%)";
                    }
                }
            }
        }
        // Add birthday cake marker (independent of month markers)
        if (this.plugin.settings.showBirthdayMarker) {
            const [year, month, day] = this.plugin.settings.birthday
                .split("-")
                .map(Number);
            const birthdayDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript
            const birthMonth = birthdayDate.getMonth();
            const birthDay = birthdayDate.getDate();
            const birthYear = birthdayDate.getFullYear();
            const birthMonthName = MONTH_NAMES[birthMonth];
            const birthdayMarkerContainer = container.createEl("div", {
                cls: "chronica-birthday-marker-container",
            });
            // Position the container near the grid
            birthdayMarkerContainer.style.position = "absolute";
            birthdayMarkerContainer.style.zIndex = "15"; // Ensure visibility above other elements
            // Create cake icon for birthday
            const cakeSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#f48fb1" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-8a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v8"/><path d="M4 16s.5-1 2-1 2.5 2 4 2 2.5-2 4-2 2.5 2 4 2 2-1 2-1"/><path d="M2 21h20"/><path d="M7 8v2"/><path d="M12 8v2"/><path d="M17 8v2"/><path d="M7 4h.01"/><path d="M12 4h.01"/><path d="M17 4h.01"/></svg>`;
            const cakeEl = birthdayMarkerContainer.createEl("div", {
                cls: "birthday-cake-marker",
            });
            cakeEl.innerHTML = cakeSvg;
            cakeEl.setAttribute("title", `${birthMonthName} ${birthDay}, ${birthYear} (Your Birthday)`);
        }
        // Create markers container with structured layout
        const isPortrait = this.plugin.settings.gridOrientation === "portrait";
        const markersContainer = container.createEl("div", {
            cls: `chronica-vertical-markers ${isPortrait ? "portrait-mode" : ""}`,
        });
        // First, create the separate containers for week and month markers
        const weekMarkersContainer = markersContainer.createEl("div", {
            cls: "chronica-week-markers",
        });
        const monthMarkersContainer = markersContainer.createEl("div", {
            cls: "chronica-month-markers",
        });
        // Add week markers (10, 20, 30, 40, 50) if enabled
        if (this.plugin.settings.showWeekMarkers) {
            for (let week = 0; week <= 50; week += 10) {
                if (week === 0)
                    continue; // Skip 0 to start with 10
                const marker = weekMarkersContainer.createEl("div", {
                    cls: `chronica-week-marker ${isPortrait ? "portrait-mode" : ""}`,
                    text: week.toString(),
                });
                // Calculate the exact position - align to grid
                const position = week * (cellSize + cellGap) +
                    cellSize / 2 -
                    (cellSize + cellGap) -
                    (cellSize + cellGap);
                if (isPortrait) {
                    marker.style.left = `${position + 6.5}px`;
                    marker.style.top = "10px"; // Fixed position from the top
                    marker.style.transform = "none"; // Remove any transforms
                }
                else {
                    marker.style.top = `${position}px`;
                    marker.style.left = "auto";
                    marker.style.right = "4px";
                }
            }
        }
        // Add month markers if enabled
        if (this.plugin.settings.showMonthMarkers) {
            const [year, month, day] = this.plugin.settings.birthday
                .split("-")
                .map(Number);
            const birthdayDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript
            const birthMonth = birthdayDate.getMonth();
            birthdayDate.getDate();
            const birthYear = birthdayDate.getFullYear();
            const birthMonthName = MONTH_NAMES[birthMonth];
            // Calculate which week of the month the birthday falls in
            // First, get first day of birth month
            const firstDayOfBirthMonth = new Date(birthYear, birthMonth, 1);
            // Calculate days between first of month and birthday
            const daysBetween = (birthdayDate.getTime() - firstDayOfBirthMonth.getTime()) /
                (1000 * 60 * 60 * 24);
            // Calculate which week of the month (0-indexed) the birthday falls in
            const birthWeekOfMonth = Math.floor(daysBetween / 7);
            // Now calculate the position for the birth month marker
            // If birthday is in week 3 of the month (0-indexed), place month marker at week 51 (second-to-last row)
            // If birthday is in week 2 of the month, place month marker at week 0 (last row)
            // If birthday is in week 1 of the month, place month marker at week 1 (first row)
            const birthMonthMarkerWeek = (52 - birthWeekOfMonth) % 52;
            // Calculate month markers from the plugin
            const monthMarkers = this.plugin.calculateMonthMarkers(birthdayDate, this.plugin.settings.lifespan, this.plugin.settings.monthMarkerFrequency);
            // Create a map to store one marker per month
            const monthMarkersMap = new Map();
            // Process all markers to find the best one for each month
            for (const marker of monthMarkers) {
                const monthIndex = MONTH_NAMES.indexOf(marker.label);
                if (monthIndex === -1)
                    continue; // Skip if not a valid month
                // Skip if this is the birth month - we'll handle it separately
                if (monthIndex === birthMonth)
                    continue;
                // Calculate the actual week position within the grid (0-51)
                const weekPosition = marker.weekIndex % 52;
                // Only add this month if we haven't seen it yet
                if (!monthMarkersMap.has(monthIndex)) {
                    monthMarkersMap.set(monthIndex, {
                        label: marker.label,
                        weekIndex: weekPosition,
                        isFirstOfYear: marker.isFirstOfYear,
                        fullLabel: marker.fullLabel,
                        monthNumber: marker.monthNumber,
                    });
                }
            }
            // Manually add the birth month marker at the calculated position
            monthMarkersMap.set(birthMonth, {
                label: birthMonthName,
                weekIndex: birthMonthMarkerWeek,
                isFirstOfYear: birthMonth === 0,
                fullLabel: `${birthMonthName} ${birthYear} (Birth Month)`,
                monthNumber: birthMonth,
            });
            // Render all month markers
            for (const [monthIndex, marker] of monthMarkersMap.entries()) {
                // Create marker element
                const markerEl = monthMarkersContainer.createEl("div", {
                    cls: `chronica-month-marker ${marker.isFirstOfYear ? "first-of-year" : ""} ${monthIndex === birthMonth ? "birth-month" : ""} ${isPortrait ? "portrait-mode" : ""}`,
                });
                // Add the month name
                markerEl.textContent = marker.label;
                // Position the marker based on orientation
                if (isPortrait) {
                    if (marker.monthNumber !== undefined) {
                        // Calculate position based on month number for even spacing
                        const weekPosition = marker.weekIndex % 52;
                        markerEl.style.left = `${weekPosition * (cellSize + cellGap) +
                            (cellSize + cellGap) +
                            cellSize / 2}px`;
                        markerEl.style.top = `10px`; // Fixed distance from the top
                        markerEl.style.transform = "translateX(-50%)"; // Center marker on its position
                    }
                    else {
                        // Original landscape positioning logic
                        markerEl.style.top = `${marker.weekIndex * (cellSize + cellGap) + cellSize / 2}px`;
                    }
                    markerEl.style.top = `${leftOffset - 80}px`;
                    markerEl.style.transform = "translateX(0)"; // Changed from 110% to prevent overlap
                }
                else {
                    markerEl.style.top = `${marker.weekIndex * (cellSize + cellGap) + cellSize / 2}px`;
                }
                // Special styling for birth month
                if (monthIndex === birthMonth && !markerEl.innerHTML.includes("svg")) {
                    markerEl.style.color = "#e91e63"; // Pink color
                    markerEl.style.fontWeight = "500";
                }
            }
        }
        // Create the grid container
        const gridEl = container.createEl("div", { cls: "chronica-grid" });
        gridEl.toggleClass("shape-circle", this.plugin.settings.cellShape === "circle");
        gridEl.toggleClass("shape-diamond", this.plugin.settings.cellShape === "diamond");
        // Use display block instead of grid, as we'll manually position each cell
        gridEl.style.display = "block";
        gridEl.style.position = "absolute";
        gridEl.style.top = `${topOffset}px`;
        gridEl.style.left = `${leftOffset}px`;
        const now = new Date();
        const [year, month, day] = this.plugin.settings.birthday
            .split("-")
            .map(Number);
        const birthdayDate = new Date(year, month - 1, day); // Month is 0-indexed in JavaScript
        const ageInWeeks = this.plugin.getFullWeekAge(birthdayDate, now);
        const currentWeekKey = this.plugin.getWeekKeyFromDate(now);
        // For each year of life (column)
        for (let year = 0; year < this.plugin.settings.lifespan; year++) {
            // Get calendar year to display (birth year + year)
            const displayYear = birthdayDate.getFullYear() + year;
            // Get birthday week information for this year
            const birthdayWeekInfo = this.plugin.getBirthdayWeekForYear(displayYear);
            // For each week in this year
            for (let week = 0; week < 52; week++) {
                const weekIndex = year * 52 + week;
                const cell = gridEl.createEl("div", { cls: "chronica-grid-cell" });
                // Calculate the date for this week relative to the birthday week start
                const cellDate = new Date(birthdayWeekInfo.weekStart);
                cellDate.setDate(cellDate.getDate() + week * 7);
                // Get calendar information for display
                const { week: cellWeek, year: isoYear } = this.plugin.getISOWeekYearNumber(cellDate);
                const weekKey = `${isoYear}-W${cellWeek.toString().padStart(2, "0")}`;
                cell.dataset.weekKey = weekKey;
                // Calculate the date range directly from the actual cell date
                const firstDayOfWeek = new Date(cellDate);
                const lastDayOfWeek = new Date(cellDate);
                lastDayOfWeek.setDate(firstDayOfWeek.getDate() + 6);
                // Format the dates
                const formatDate = (date) => {
                    const months = [
                        "Jan",
                        "Feb",
                        "Mar",
                        "Apr",
                        "May",
                        "Jun",
                        "Jul",
                        "Aug",
                        "Sep",
                        "Oct",
                        "Nov",
                        "Dec",
                    ];
                    return `${months[date.getMonth()]} ${date.getDate()}`;
                };
                const dateRange = `${formatDate(firstDayOfWeek)} - ${formatDate(lastDayOfWeek)}`;
                cell.setAttribute("title", `Week ${cellWeek}, ${isoYear}\n${dateRange}`);
                // Position the cell with absolute positioning
                cell.style.position = "absolute";
                // Calculate year position with decade spacing
                const yearPos = this.plugin.calculateYearPosition(year, cellSize, regularGap);
                // Calculate week position (simple)
                const weekPos = week * (cellSize + regularGap);
                // Position based on orientation
                if (this.plugin.settings.gridOrientation === "landscape") {
                    // Landscape mode (default): years as columns, weeks as rows
                    cell.style.left = `${yearPos}px`;
                    cell.style.top = `${weekPos}px`;
                }
                else {
                    // Portrait mode: years as rows, weeks as columns
                    cell.style.left = `${weekPos}px`;
                    cell.style.top = `${yearPos}px`;
                }
                // Explicitly set width and height (previously handled by grid)
                cell.style.width = `${cellSize}px`;
                cell.style.height = `${cellSize}px`;
                // Color coding (past, present, future)
                const isCurrentWeek = weekKey === currentWeekKey;
                const hasEvent = this.applyEventStyling(cell, weekKey);
                // Add appropriate class regardless of color
                if (isCurrentWeek) {
                    cell.addClass("present");
                }
                else if (cellDate < now) {
                    cell.addClass("past");
                }
                else {
                    cell.addClass("future");
                }
                // Only apply base color coding if there's no event
                if (!hasEvent) {
                    if (isCurrentWeek) {
                        cell.style.backgroundColor = this.plugin.settings.presentCellColor;
                    }
                    else if (cellDate < now) {
                        cell.style.backgroundColor = this.plugin.settings.pastCellColor;
                    }
                    else {
                        cell.style.backgroundColor = this.plugin.settings.futureCellColor;
                    }
                }
                // Add click and context menu events to the cell
                cell.addEventListener("click", async (event) => {
                    // If shift key is pressed, add an event
                    if (event.shiftKey) {
                        const modal = new ChronosEventModal(this.app, this.plugin, weekKey);
                        modal.open();
                        return;
                    }
                    // Otherwise open/create the weekly note
                    const fileName = `${weekKey.replace("W", "-W")}.md`;
                    const fullPath = this.plugin.getFullPath(fileName);
                    const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
                    if (existingFile instanceof obsidian.TFile) {
                        // Replace this line:
                        // await this.app.workspace.getLeaf().openFile(existingFile);
                        // With this line:
                        await this.plugin.safelyOpenFile(existingFile);
                    }
                    else {
                        // Create new file with template
                        if (this.plugin.settings.notesFolder &&
                            this.plugin.settings.notesFolder.trim() !== "") {
                            try {
                                const folderExists = this.app.vault.getAbstractFileByPath(this.plugin.settings.notesFolder);
                                if (!folderExists) {
                                    await this.app.vault.createFolder(this.plugin.settings.notesFolder);
                                }
                            }
                            catch (err) {
                                console.log("Error checking/creating folder:", err);
                            }
                        }
                        const isoYear = weekKey.split("-W")[0]; // Extract the year from the weekKey
                        const content = `# Week ${cellWeek}, ${isoYear}\n\n## Reflections\n\n## Tasks\n\n## Notes\n`;
                        const newFile = await this.app.vault.create(fullPath, content);
                        // Replace this line:
                        // await this.app.workspace.getLeaf().openFile(newFile);
                        // With this line:
                        await this.plugin.safelyOpenFile(newFile);
                    }
                });
                // Add context menu (right-click) event for manual fill
                cell.addEventListener("contextmenu", (event) => {
                    // Only allow manual fill if auto-fill is disabled and for future weeks
                    if (this.plugin.settings.enableAutoFill || weekIndex <= ageInWeeks) {
                        return;
                    }
                    // Prevent default context menu
                    event.preventDefault();
                    // Toggle filled status
                    const filledIndex = this.plugin.settings.filledWeeks.indexOf(weekKey);
                    if (filledIndex >= 0) {
                        // Remove from filled weeks
                        this.plugin.settings.filledWeeks.splice(filledIndex, 1);
                        cell.removeClass("filled-week");
                    }
                    else {
                        // Add to filled weeks
                        this.plugin.settings.filledWeeks.push(weekKey);
                        cell.addClass("filled-week");
                        cell.style.backgroundColor = "#8bc34a"; // Light green for filled weeks
                    }
                    // Save settings
                    this.plugin.saveSettings();
                });
            }
        }
    }
    /**
     * Render the statistics panel
     * @param container - Container to render panel in
     */
    renderStatsPanel(container) {
        // Create the stats handle (always visible)
        const statsHandle = container.createEl("div", {
            cls: "chronica-stats-handle",
        });
        statsHandle.innerHTML = `
    <svg class="chronica-stats-handle-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <path d="M18 20V10M12 20V4M6 20v-6"></path>
    </svg>
    <span>Statistics</span>
  `;
        statsHandle.setAttribute("title", this.isStatsOpen ? "Hide Statistics" : "Show Statistics");
        // Create stats panel container with appropriate classes
        const statsPanel = container.createEl("div", {
            cls: `chronica-stats-panel ${this.isStatsOpen ? "expanded" : "collapsed"}`,
        });
        // Use CSS variables for height, don't set inline styles
        if (this.isStatsOpen) {
            // Update the content area's class to add padding
            const contentArea = this.containerEl.querySelector(".chronica-content-area");
            if (contentArea) {
                contentArea.classList.add("stats-expanded");
            }
        }
        // Create header
        const statsHeader = statsPanel.createEl("div", {
            cls: "chronica-stats-header",
        });
        // Set up horizontal dragging via header
        this.setupStatsPanelHorizontalDrag(statsHeader, statsPanel, statsHandle);
        // Add drag handle for resizing
        const dragHandle = statsHeader.createEl("div", {
            cls: "chronica-stats-drag-handle",
        });
        // Create tabs container
        const tabsContainer = statsHeader.createEl("div", {
            cls: "chronica-stats-tabs",
        });
        // Define tabs
        const tabs = [
            { id: "overview", label: "Overview" },
            { id: "events", label: "Events" },
            { id: "timeline", label: "Timeline" },
            { id: "charts", label: "Charts" },
        ];
        // Add tab buttons
        tabs.forEach((tab) => {
            const tabButton = tabsContainer.createEl("button", {
                cls: `chronica-stats-tab ${this.plugin.settings.activeStatsTab === tab.id ? "active" : ""}`,
                text: tab.label,
            });
            tabButton.dataset.tabId = tab.id;
            // Add click event handler
            tabButton.addEventListener("click", () => {
                // Store active tab
                this.plugin.settings.activeStatsTab = tab.id;
                this.plugin.saveSettings();
                // Update UI (use class-based approach like sidebar)
                tabsContainer.querySelectorAll(".chronica-stats-tab").forEach((btn) => {
                    btn.classList.toggle("active", btn.getAttribute("data-tab-id") === tab.id);
                });
                // Update content
                statsPanel
                    .querySelectorAll(".chronica-stats-tab-content")
                    .forEach((content) => {
                    content.classList.toggle("active", content.id === `tab-content-${tab.id}`);
                });
            });
        });
        // Add content container
        const contentContainer = statsPanel.createEl("div", {
            cls: "chronica-stats-content",
        });
        // Create tab content areas
        tabs.forEach((tab) => {
            const tabContent = contentContainer.createEl("div", {
                cls: `chronica-stats-tab-content ${this.plugin.settings.activeStatsTab === tab.id ? "active" : ""}`,
                attr: { id: `tab-content-${tab.id}` },
            });
            // Add tab-specific content
            if (tab.id === "overview") {
                this.renderOverviewTab(tabContent);
            }
            else if (tab.id === "events") {
                this.renderEventsTab(tabContent);
            }
            else if (tab.id === "timeline") {
                this.renderTimelineTab(tabContent);
            }
            else if (tab.id === "charts") {
                this.renderChartsTab(tabContent);
            }
        });
        statsHandle.addEventListener("click", () => {
            // Flip state
            this.isStatsOpen = !this.isStatsOpen;
            this.plugin.settings.isStatsOpen = this.isStatsOpen;
            this.plugin.saveSettings();
            // Update classes
            statsPanel.classList.toggle("expanded", this.isStatsOpen);
            statsPanel.classList.toggle("collapsed", !this.isStatsOpen);
            // Important: Set explicit panel height when expanding
            if (this.isStatsOpen) {
                statsPanel.style.height = `${this.plugin.settings.statsPanelHeight}px`;
                document.documentElement.style.setProperty("--stats-panel-height", `${this.plugin.settings.statsPanelHeight}px`);
            }
            else {
                statsPanel.style.height = "0";
            }
            // Update content area padding
            const contentArea = this.containerEl.querySelector(".chronica-content-area");
            if (contentArea) {
                contentArea.classList.toggle("stats-expanded", this.isStatsOpen);
            }
            // Update tooltip text
            statsHandle.setAttribute("title", this.isStatsOpen ? "Hide Statistics" : "Show Statistics");
        });
        // Setup resize functionality with simplified approach
        this.setupStatsPanelResize(dragHandle, statsPanel);
        // Setup horizontal resize
        this.setupStatsPanelWidthResize(statsPanel);
    }
    /**
     * Setup the resize functionality for the stats panel
     * @param dragHandle - Handle element for dragging
     * @param statsPanel - Panel to resize
     */
    setupStatsPanelResize(dragHandle, statsPanel) {
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startOffset = 0;
        const onMouseDown = (e) => {
            // Only respond to left mouse button
            if (e.button !== 0)
                return;
            e.preventDefault(); // Prevent text selection
            // Get the current height and horizontal offset
            startHeight = this.plugin.settings.statsPanelHeight;
            startOffset = this.plugin.settings.statsPanelHorizontalOffset || 0;
            startX = e.clientX;
            startY = e.clientY;
            // Add event listeners
            document.addEventListener("mousemove", onMouseMove);
            document.addEventListener("mouseup", onMouseUp);
        };
        const onMouseMove = (e) => {
            // Calculate vertical change (dragging up/down)
            const deltaY = startY - e.clientY;
            const newHeight = Math.max(150, Math.min(600, startHeight + deltaY));
            // Calculate horizontal change (dragging left/right)
            const deltaX = e.clientX - startX;
            // Calculate boundaries to keep panel visible
            const windowWidth = window.innerWidth;
            const panelWidth = statsPanel.getBoundingClientRect().width;
            const maxOffset = (windowWidth - panelWidth) / 2;
            const newOffset = Math.max(-maxOffset, Math.min(maxOffset, startOffset + deltaX));
            // Update CSS variable for height
            document.documentElement.style.setProperty("--stats-panel-height", `${newHeight}px`);
            // Update panel height and position
            statsPanel.style.height = `${newHeight}px`;
            statsPanel.style.transform = `translateX(calc(-50% + ${newOffset}px))`;
            // Update the handle position to match
            const statsHandle = this.containerEl.querySelector(".chronica-stats-handle");
            if (statsHandle) {
                statsHandle.style.transform = `translateX(calc(-50% + ${newOffset}px))`;
            }
            // Update content area padding for height
            const contentArea = this.containerEl.querySelector(".chronica-content-area");
            if (contentArea && this.isStatsOpen) ;
            // Update settings (but don't save yet to avoid performance issues)
            this.plugin.settings.statsPanelHeight = newHeight;
            this.plugin.settings.statsPanelHorizontalOffset = newOffset;
        };
        const onMouseUp = () => {
            // Remove event listeners
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            // Save settings once at the end of resize
            this.plugin.saveSettings();
        };
        // Add initial event listener
        dragHandle.addEventListener("mousedown", onMouseDown);
    }
    updateStatsPanelLayout() {
        const statsPanel = this.containerEl.querySelector(".chronica-stats-panel");
        const statsHandle = this.containerEl.querySelector(".chronica-stats-handle");
        const contentArea = this.containerEl.querySelector(".chronica-content-area");
        const sidebar = this.containerEl.querySelector(".chronica-sidebar");
        if (!statsPanel || !contentArea || !statsHandle)
            return;
        // Set panel height
        const panelHeight = this.plugin.settings.statsPanelHeight;
        document.documentElement.style.setProperty("--stats-panel-height", `${panelHeight}px`);
        // Get horizontal offset
        const horizontalOffset = this.plugin.settings.statsPanelHorizontalOffset || 0;
        // Get the total window width and calculate the available width
        this.containerEl.clientWidth;
        const sidebarWidth = this.isSidebarOpen && sidebar ? sidebar.getBoundingClientRect().width : 0;
        // Calculate the center of the available space
        const offsetX = this.isSidebarOpen ? sidebarWidth / 2 : 0;
        // Position the handle and panel base positions (before transform)
        statsPanel.style.left = `calc(50% + ${offsetX}px)`;
        statsHandle.style.left = `calc(50% + ${offsetX}px)`;
        // Apply horizontal offset via transform
        statsPanel.style.transform = `translateX(calc(-50% + ${horizontalOffset}px))`;
        statsHandle.style.transform = `translateX(calc(-50% + ${horizontalOffset}px))`;
        // Set height based on panel state
        if (this.isStatsOpen) {
            contentArea.classList.add("stats-expanded");
            statsPanel.style.height = `${panelHeight}px`;
            statsPanel.style.width = `${this.plugin.settings.statsPanelWidth}px`;
        }
        else {
            contentArea.classList.remove("stats-expanded");
            statsPanel.style.height = "0";
            contentArea.style.paddingBottom = "0";
        }
    }
    /**
     * Render the Overview tab content
     * @param container - Container to render tab content in
     */
    renderOverviewTab(container) {
        // Calculate statistics
        const now = new Date();
        const [year, month, day] = this.plugin.settings.birthday
            .split("-")
            .map(Number);
        const birthdayDate = new Date(year, month - 1, day);
        const ageInWeeks = this.plugin.getFullWeekAge(birthdayDate, now);
        const totalWeeks = this.plugin.settings.lifespan * 52;
        const livedPercentage = Math.min(100, Math.max(0, (ageInWeeks / totalWeeks) * 100));
        const remainingWeeks = Math.max(0, totalWeeks - ageInWeeks);
        // Count events
        const majorLifeEvents = this.plugin.settings.greenEvents.length;
        const travelEvents = this.plugin.settings.blueEvents.length;
        const relationshipEvents = this.plugin.settings.pinkEvents.length;
        const educationCareerEvents = this.plugin.settings.purpleEvents.length;
        // Calculate custom event counts
        let customEventCount = 0;
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEvents) {
            for (const eventType of this.plugin.settings.customEventTypes) {
                if (this.plugin.settings.customEvents[eventType.name]) {
                    customEventCount +=
                        this.plugin.settings.customEvents[eventType.name].length;
                }
            }
        }
        const totalEvents = majorLifeEvents +
            travelEvents +
            relationshipEvents +
            educationCareerEvents +
            customEventCount;
        // Create main container with grid layout
        const overviewGrid = container.createEl("div", {
            cls: "chronica-stats-grid",
        });
        // Left side: Life progress section
        const progressSection = overviewGrid.createEl("div", {
            cls: "chronica-stat-section",
        });
        // Life progress card
        const lifeSummary = progressSection.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        lifeSummary.createEl("div", {
            cls: "chronica-stat-title",
            text: "Life Progress",
        });
        // Create circular progress and bar in the same container
        const progressContainer = lifeSummary.createEl("div", {
            cls: "chronica-progress-container",
        });
        // Create circular progress on the left
        const circleContainer = progressContainer.createEl("div", {
            cls: "chronica-circular-progress",
        });
        const progressValue = Math.round(livedPercentage);
        circleContainer.innerHTML = `
    <svg width="60" height="60" viewBox="0 0 80 80">
      <circle cx="40" cy="40" r="35" fill="none" stroke="var(--background-modifier-border)" stroke-width="5"></circle>
      <circle cx="40" cy="40" r="35" fill="none" stroke="var(--interactive-accent)" stroke-width="5"
        stroke-dasharray="220" stroke-dashoffset="${220 - (220 * livedPercentage) / 100}"
        transform="rotate(-90 40 40)"></circle>
    </svg>
    <div class="chronica-circular-progress-text">${progressValue}%</div>
  `;
        // Create bar and text on the right
        const barContainer = progressContainer.createEl("div", {
            cls: "chronica-bar-container",
        });
        const progressBar = barContainer.createEl("div", {
            cls: "chronica-progress-bar",
        });
        const progressFill = progressBar.createEl("div", {
            cls: "chronica-progress-bar-fill",
        });
        progressFill.style.width = `${livedPercentage}%`;
        barContainer.createEl("div", {
            cls: "chronica-stat-subtitle",
            text: `${ageInWeeks} weeks lived, ${remainingWeeks} weeks remaining`,
        });
        // Right side: Additional stats
        // Current age card
        const ageCard = overviewGrid.createEl("div", {
            cls: "chronica-stat-card",
        });
        ageCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Current Age",
        });
        const yearsLived = Math.floor(ageInWeeks / 52);
        const remainingWeeksInYear = ageInWeeks % 52;
        ageCard.createEl("div", {
            cls: "chronica-stat-value",
            text: `${yearsLived} years, ${remainingWeeksInYear} weeks`,
        });
        // Calculate decades lived
        const decadesLived = Math.floor(yearsLived / 10);
        const yearsIntoCurrentDecade = yearsLived % 10;
        ageCard.createEl("div", {
            cls: "chronica-stat-subtitle",
            text: `${decadesLived} decades + ${yearsIntoCurrentDecade} years`,
        });
        // Events count card
        const eventsCard = overviewGrid.createEl("div", {
            cls: "chronica-stat-card",
        });
        eventsCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Total Events",
        });
        eventsCard.createEl("div", {
            cls: "chronica-stat-value",
            text: totalEvents.toString(),
        });
        let eventBreakdown = "";
        if (majorLifeEvents > 0)
            eventBreakdown += `${majorLifeEvents} major, `;
        if (travelEvents > 0)
            eventBreakdown += `${travelEvents} travel, `;
        if (relationshipEvents > 0)
            eventBreakdown += `${relationshipEvents} relationship, `;
        if (educationCareerEvents > 0)
            eventBreakdown += `${educationCareerEvents} career, `;
        if (customEventCount > 0)
            eventBreakdown += `${customEventCount} custom`;
        // Remove trailing comma and space
        eventBreakdown = eventBreakdown.replace(/,\s*$/, "");
        eventsCard.createEl("div", {
            cls: "chronica-stat-subtitle",
            text: eventBreakdown || "No events added yet",
        });
        // Birthday info card
        const birthdayCard = overviewGrid.createEl("div", {
            cls: "chronica-stat-card",
        });
        birthdayCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Birthday",
        });
        const formatBirthday = (date) => {
            const months = [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ];
            return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
        };
        birthdayCard.createEl("div", {
            cls: "chronica-stat-value",
            text: formatBirthday(birthdayDate),
        });
        const nextBirthdayDate = new Date(birthdayDate);
        nextBirthdayDate.setFullYear(now.getFullYear());
        // If this year's birthday has passed, look at next year's
        if (nextBirthdayDate < now) {
            nextBirthdayDate.setFullYear(now.getFullYear() + 1);
        }
        const daysUntilBirthday = Math.ceil((nextBirthdayDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        birthdayCard.createEl("div", {
            cls: "chronica-stat-subtitle",
            text: `Next birthday in ${daysUntilBirthday} days`,
        });
    }
    /**
     * Render the Events tab content with visualizations and event lists
     * @param container - Container to render tab content in
     */
    renderEventsTab(container) {
        // Create main header
        container.createEl("h3", { text: "Event Statistics" });
        // Get event counts
        const majorLifeEvents = this.plugin.settings.greenEvents.length;
        const travelEvents = this.plugin.settings.blueEvents.length;
        const relationshipEvents = this.plugin.settings.pinkEvents.length;
        const educationCareerEvents = this.plugin.settings.purpleEvents.length;
        // Calculate custom event counts
        let customEventCount = 0;
        let customEvents = [];
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEvents) {
            for (const eventType of this.plugin.settings.customEventTypes) {
                const count = this.plugin.settings.customEvents[eventType.name]?.length || 0;
                customEventCount += count;
                if (count > 0) {
                    customEvents.push({
                        name: eventType.name,
                        count: count,
                        color: eventType.color,
                    });
                }
            }
        }
        const totalEvents = majorLifeEvents +
            travelEvents +
            relationshipEvents +
            educationCareerEvents +
            customEventCount;
        // If there are no events, show a message
        if (totalEvents === 0) {
            container.createEl("div", {
                cls: "chronica-empty-state",
                text: "No events added yet. Add events to see statistics and distributions.",
            });
            return;
        }
        // Create grid layout for stats
        const statsGrid = container.createEl("div", {
            cls: "chronica-stats-grid",
        });
        // Create distribution section
        const distributionCard = statsGrid.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        distributionCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Event Type Distribution",
        });
        // Create bar chart for event distribution
        const chartContainer = distributionCard.createEl("div", {
            cls: "chronica-event-chart-container",
        });
        // Standard event types
        const standardEvents = [
            { name: "Major Life", count: majorLifeEvents, color: "#4CAF50" },
            { name: "Travel", count: travelEvents, color: "#2196F3" },
            { name: "Relationship", count: relationshipEvents, color: "#E91E63" },
            {
                name: "Education/Career",
                count: educationCareerEvents,
                color: "#D2B55B",
            },
        ];
        // Combine standard and custom events
        const allEvents = [...standardEvents, ...customEvents].filter((e) => e.count > 0);
        // Sort by count (highest first)
        allEvents.sort((a, b) => b.count - a.count);
        // Create horizontal bar chart
        const maxCount = Math.max(...allEvents.map((e) => e.count));
        for (const event of allEvents) {
            const barRow = chartContainer.createEl("div", {
                cls: "chronica-chart-row",
            });
            barRow.createEl("div", {
                cls: "chronica-chart-label",
                text: event.name,
            });
            const barContainer = barRow.createEl("div", {
                cls: "chronica-chart-bar-container",
            });
            const barEl = barContainer.createEl("div", {
                cls: "chronica-chart-bar",
            });
            barEl.style.width = `${(event.count / maxCount) * 100}%`;
            barEl.style.backgroundColor = event.color;
            barContainer.createEl("div", {
                cls: "chronica-chart-count",
                text: event.count.toString(),
            });
        }
        // Create event list section
        const eventListCard = statsGrid.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        eventListCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Recent Events",
        });
        // Function to parse week key
        const parseWeekKey = (key) => {
            const parts = key.split("-W");
            return {
                year: parseInt(parts[0]),
                week: parseInt(parts[1]),
            };
        };
        // Collect all events into a single array
        let allEventsList = [];
        // Add standard events
        const addEvents = (events, type, color) => {
            events.forEach((eventData) => {
                const parts = eventData.split(":");
                if (parts.length === 2) {
                    // Single event
                    allEventsList.push({
                        weekKey: parts[0],
                        description: parts[1],
                        type: type,
                        color: color,
                    });
                }
                else if (parts.length === 3) {
                    // Range event
                    allEventsList.push({
                        weekKey: parts[0],
                        endWeekKey: parts[1],
                        description: parts[2],
                        type: type,
                        color: color,
                        isRange: true,
                    });
                }
            });
        };
        // Add all event types
        addEvents(this.plugin.settings.greenEvents, "Major Life", "#4CAF50");
        addEvents(this.plugin.settings.blueEvents, "Travel", "#2196F3");
        addEvents(this.plugin.settings.pinkEvents, "Relationship", "#E91E63");
        addEvents(this.plugin.settings.purpleEvents, "Education/Career", "#D2B55B");
        // Add custom events
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEvents) {
            for (const eventType of this.plugin.settings.customEventTypes) {
                if (this.plugin.settings.customEvents[eventType.name]) {
                    addEvents(this.plugin.settings.customEvents[eventType.name], eventType.name, eventType.color);
                }
            }
        }
        // Sort events by date (most recent first)
        allEventsList.sort((a, b) => {
            const aDate = parseWeekKey(a.weekKey);
            const bDate = parseWeekKey(b.weekKey);
            if (aDate.year !== bDate.year) {
                return bDate.year - aDate.year; // Most recent year first
            }
            return bDate.week - aDate.week; // Most recent week first
        });
        // Show max 10 most recent events
        const recentEvents = allEventsList.slice(0, 10);
        if (recentEvents.length > 0) {
            const eventListEl = eventListCard.createEl("div", {
                cls: "chronica-event-list",
            });
            for (const event of recentEvents) {
                const eventItem = eventListEl.createEl("div", {
                    cls: "chronica-event-item",
                });
                const colorDot = eventItem.createEl("div", {
                    cls: "chronica-event-color-dot",
                });
                colorDot.style.backgroundColor = event.color;
                let dateRange = event.weekKey;
                if (event.isRange && event.endWeekKey) {
                    dateRange = `${event.weekKey} → ${event.endWeekKey}`;
                }
                const eventInfo = eventItem.createEl("div", {
                    cls: "chronica-event-info",
                });
                eventInfo.createEl("div", {
                    cls: "chronica-event-name",
                    text: event.description,
                });
                eventInfo.createEl("div", {
                    cls: "chronica-event-meta",
                    text: `${event.type} • ${dateRange}`,
                });
            }
        }
        else {
            eventListCard.createEl("div", {
                cls: "chronica-empty-list",
                text: "No events found",
            });
        }
        // Create event statistics card
        const eventStatsCard = statsGrid.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        eventStatsCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Event Statistics",
        });
        // Calculate additional stats
        const allYears = allEventsList.map((e) => parseWeekKey(e.weekKey).year);
        const uniqueYears = [...new Set(allYears)];
        const eventsByYear = uniqueYears.length > 0
            ? (totalEvents / uniqueYears.length).toFixed(1)
            : "0";
        // Count range events
        const rangeEvents = allEventsList.filter((e) => e.isRange).length;
        const singleEvents = totalEvents - rangeEvents;
        const statsTable = eventStatsCard.createEl("table", {
            cls: "chronica-stats-table",
        });
        const addStatRow = (label, value) => {
            const row = statsTable.createEl("tr");
            row.createEl("td", { text: label });
            row.createEl("td", { text: value });
        };
        addStatRow("Total Events", totalEvents.toString());
        addStatRow("Years with Events", uniqueYears.length.toString());
        addStatRow("Average Events/Year", eventsByYear);
        addStatRow("Single-Week Events", singleEvents.toString());
        addStatRow("Multi-Week Events", rangeEvents.toString());
    }
    /**
     * Render the Timeline tab content with life phases and milestone analysis
     * @param container - Container to render tab content in
     */
    renderTimelineTab(container) {
        // Calculate statistics
        const now = new Date();
        const [birthYear, birthMonth, birthDay] = this.plugin.settings.birthday
            .split("-")
            .map(Number);
        const birthdayDate = new Date(birthYear, birthMonth - 1, birthDay);
        const ageInWeeks = this.plugin.getFullWeekAge(birthdayDate, now);
        this.plugin.settings.lifespan * 52;
        // Create main container with grid layout
        const timelineGrid = container.createEl("div", {
            cls: "chronica-stats-grid",
        });
        // Create life phases card
        const phasesCard = timelineGrid.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        phasesCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Life Phases",
        });
        // Calculate current phase
        const ageInYears = ageInWeeks / 52;
        let currentPhase = "";
        let phaseColor = "";
        if (ageInYears < 5) {
            currentPhase = "Early Childhood";
            phaseColor = "#8BC34A"; // Light green
        }
        else if (ageInYears < 13) {
            currentPhase = "Childhood";
            phaseColor = "#4CAF50"; // Green
        }
        else if (ageInYears < 18) {
            currentPhase = "Adolescence";
            phaseColor = "#009688"; // Teal
        }
        else if (ageInYears < 25) {
            currentPhase = "Young Adult";
            phaseColor = "#00BCD4"; // Cyan
        }
        else if (ageInYears < 40) {
            currentPhase = "Early Adulthood";
            phaseColor = "#03A9F4"; // Light blue
        }
        else if (ageInYears < 60) {
            currentPhase = "Middle Adulthood";
            phaseColor = "#3F51B5"; // Indigo
        }
        else {
            currentPhase = "Late Adulthood";
            phaseColor = "#9C27B0"; // Purple
        }
        // Create phase visualization
        const phaseBar = phasesCard.createEl("div", {
            cls: "chronica-phase-bar",
        });
        // Define life phases - customize as needed
        const phases = [
            { name: "Childhood", end: 18, color: "#4CAF50" },
            { name: "Young Adult", end: 25, color: "#00BCD4" },
            { name: "Early Adult", end: 40, color: "#03A9F4" },
            { name: "Middle Adult", end: 60, color: "#3F51B5" },
            {
                name: "Late Adult",
                end: this.plugin.settings.lifespan,
                color: "#9C27B0",
            },
        ];
        // Calculate total width for all phases
        let totalWidth = 0;
        phases.forEach((phase) => {
            let phaseWidth;
            if (phase.name === "Childhood") {
                phaseWidth = phase.end;
            }
            else {
                const prevPhase = phases[phases.indexOf(phase) - 1];
                phaseWidth = phase.end - prevPhase.end;
            }
            totalWidth += phaseWidth;
        });
        phases.forEach((phase) => {
            let phaseWidth;
            if (phase.name === "Childhood") {
                phaseWidth = phase.end;
            }
            else {
                const prevPhase = phases[phases.indexOf(phase) - 1];
                phaseWidth = phase.end - prevPhase.end;
            }
            const relativeWidth = (phaseWidth / totalWidth) * 100;
            const phaseSegment = phaseBar.createEl("div", {
                cls: "chronica-phase-segment",
            });
            phaseSegment.style.width = `${relativeWidth}%`;
            phaseSegment.style.backgroundColor = phase.color;
            // Add label
            phaseSegment.createEl("div", {
                cls: "chronica-phase-label",
                text: phase.name,
            });
            // Add age marker
            phaseSegment.createEl("div", {
                cls: "chronica-phase-age",
                text: phase.end.toString(),
            });
            // Add current position marker if in this phase
            if (ageInYears <= phase.end &&
                (phase.name === "Childhood" ||
                    ageInYears > phases[phases.indexOf(phase) - 1].end)) {
                const markerPosition = phase.name === "Childhood"
                    ? (ageInYears / phase.end) * 100
                    : ((ageInYears - phases[phases.indexOf(phase) - 1].end) /
                        phaseWidth) *
                        100;
                const currentMarker = phaseSegment.createEl("div", {
                    cls: "chronica-current-marker",
                });
                currentMarker.style.left = `${markerPosition}%`;
            }
        });
        // Current phase information
        phasesCard.createEl("div", {
            cls: "chronica-current-phase",
            text: `Current phase: ${currentPhase} (${Math.floor(ageInYears)} years old)`,
        }).style.color = phaseColor;
        // Milestones card
        const milestonesCard = timelineGrid.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        milestonesCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Life Milestones",
        });
        // Create milestone table
        const milestoneTable = milestonesCard.createEl("table", {
            cls: "chronica-milestone-table",
        });
        // Header row
        const headerRow = milestoneTable.createEl("tr");
        headerRow.createEl("th", { text: "Milestone" });
        headerRow.createEl("th", { text: "Age" });
        headerRow.createEl("th", { text: "Date" });
        headerRow.createEl("th", { text: "Status" });
        // Add milestone rows
        const addMilestone = (name, age) => {
            const milestoneDate = new Date(birthdayDate);
            milestoneDate.setFullYear(birthdayDate.getFullYear() + age);
            const row = milestoneTable.createEl("tr");
            row.createEl("td", { text: name });
            row.createEl("td", { text: age.toString() });
            // Format date
            const formatDate = (date) => {
                const months = [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec",
                ];
                return `${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;
            };
            row.createEl("td", { text: formatDate(milestoneDate) });
            const isPast = milestoneDate < now;
            const statusCell = row.createEl("td");
            statusCell.addClass(isPast ? "milestone-past" : "milestone-future");
            statusCell.textContent = isPast ? "Passed" : "Upcoming";
        };
        // Add standard milestones - customize these as needed
        addMilestone("Childhood End", 18);
        addMilestone("Quarter Life", Math.round(this.plugin.settings.lifespan / 4));
        addMilestone("Half Life", Math.round(this.plugin.settings.lifespan / 2));
        addMilestone("Retirement Age", 65);
        addMilestone("Three-Quarter Life", Math.round(this.plugin.settings.lifespan * 0.75));
        // Week completion card
        const completionCard = timelineGrid.createEl("div", {
            cls: "chronica-stat-card chronica-stat-card-full",
        });
        completionCard.createEl("div", {
            cls: "chronica-stat-title",
            text: "Week Completion",
        });
        // Calculate week completion statistics
        const filledWeeks = this.plugin.settings.filledWeeks.length;
        const pastWeeks = ageInWeeks;
        const completionRate = pastWeeks > 0 ? (filledWeeks / pastWeeks) * 100 : 0;
        completionCard.createEl("div", {
            cls: "chronica-completion-stat",
            text: `${filledWeeks} weeks filled out of ${Math.round(pastWeeks)} past weeks (${completionRate.toFixed(1)}%)`,
        });
        // Week completion progress bar
        const completionBar = completionCard.createEl("div", {
            cls: "chronica-progress-bar",
        });
        const completionFill = completionBar.createEl("div", {
            cls: "chronica-progress-bar-fill",
        });
        completionFill.style.width = `${completionRate}%`;
        // Get events for analysis
        const greenEvents = this.plugin.settings.greenEvents.length;
        const blueEvents = this.plugin.settings.blueEvents.length;
        const pinkEvents = this.plugin.settings.pinkEvents.length;
        const purpleEvents = this.plugin.settings.purpleEvents.length;
        // Calculate custom event counts
        let customEventCount = 0;
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEvents) {
            for (const eventType of this.plugin.settings.customEventTypes) {
                if (this.plugin.settings.customEvents[eventType.name]) {
                    customEventCount +=
                        this.plugin.settings.customEvents[eventType.name].length;
                }
            }
        }
        const totalEvents = greenEvents + blueEvents + pinkEvents + purpleEvents + customEventCount;
        const eventsPerWeek = pastWeeks > 0 ? totalEvents / pastWeeks : 0;
        completionCard.createEl("div", {
            cls: "chronica-completion-stat",
            text: `${totalEvents} events recorded (${eventsPerWeek.toFixed(3)} events/week)`,
        });
    }
    /**
     * Render the Charts tab content with improved visualizations arranged in a grid
     * @param container - Container to render tab content in
     */
    renderChartsTab(container) {
        // Calculate statistics
        const now = new Date();
        this.plugin.settings.birthday
            .split("-")
            .map(Number);
        // Create main container with grid layout
        const chartsGridContainer = container.createEl("div", {
            cls: "chronica-charts-grid-container",
        });
        // Collect all events
        let allEvents = [];
        // Function to parse week key
        const parseWeekKey = (key) => {
            const parts = key.split("-W");
            if (parts.length !== 2)
                return { year: 0, week: 0 };
            return {
                year: parseInt(parts[0], 10),
                week: parseInt(parts[1], 10),
            };
        };
        // Add standard events
        const addEvents = (events, type, color) => {
            events.forEach((eventData) => {
                const parts = eventData.split(":");
                if (parts.length === 2) {
                    // Single event
                    allEvents.push({
                        weekKey: parts[0],
                        description: parts[1],
                        type: type,
                        color: color,
                    });
                }
                else if (parts.length === 3) {
                    // Range event
                    allEvents.push({
                        weekKey: parts[0],
                        endWeekKey: parts[1],
                        description: parts[2],
                        type: type,
                        color: color,
                        isRange: true,
                    });
                }
            });
        };
        // Add all event types
        addEvents(this.plugin.settings.greenEvents, "Major Life", "#4CAF50");
        addEvents(this.plugin.settings.blueEvents, "Travel", "#2196F3");
        addEvents(this.plugin.settings.pinkEvents, "Relationship", "#E91E63");
        addEvents(this.plugin.settings.purpleEvents, "Education/Career", "#D2B55B");
        // Add custom events
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEvents) {
            for (const eventType of this.plugin.settings.customEventTypes) {
                if (this.plugin.settings.customEvents[eventType.name]) {
                    addEvents(this.plugin.settings.customEvents[eventType.name], eventType.name, eventType.color);
                }
            }
        }
        // If no events, show a message
        if (allEvents.length === 0) {
            const emptyState = chartsGridContainer.createEl("div", {
                cls: "chronica-empty-chart-state",
            });
            emptyState.createEl("div", {
                cls: "chronica-empty-icon",
                text: "📊",
            });
            emptyState.createEl("div", {
                cls: "chronica-empty-message",
                text: "No events added yet",
            });
            emptyState.createEl("div", {
                cls: "chronica-empty-submessage",
                text: "Add events to see charts and visualizations",
            });
            return;
        }
        // ======== EVENT DISTRIBUTION BY TYPE CHART ========
        const pieChartCard = chartsGridContainer.createEl("div", {
            cls: "chronica-chart-card",
        });
        pieChartCard.createEl("h3", {
            cls: "chronica-chart-title",
            text: "Event Distribution by Type",
        });
        // Count events by type
        const eventsByType = {};
        allEvents.forEach((event) => {
            if (!eventsByType[event.type]) {
                eventsByType[event.type] = {
                    count: 0,
                    color: event.color,
                };
            }
            eventsByType[event.type].count++;
        });
        // Convert to array and sort by count (descending)
        const typeData = Object.entries(eventsByType)
            .map(([type, data]) => ({
            type,
            count: data.count,
            color: data.color,
        }))
            .sort((a, b) => b.count - a.count);
        // Calculate total for percentages
        const totalEvents = typeData.reduce((sum, item) => sum + item.count, 0);
        // Create donut chart container
        const pieChartContainer = pieChartCard.createEl("div", {
            cls: "chronica-donut-container",
        });
        // Create legend container
        const legendContainer = pieChartContainer.createEl("div", {
            cls: "chronica-chart-legend",
        });
        // Create the chart visualization area
        const chartArea = pieChartContainer.createEl("div", {
            cls: "chronica-donut-chart",
        });
        // Create SVG for pie chart
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("viewBox", "0 0 100 100");
        chartArea.appendChild(svg);
        // Create a group for the chart
        const g = document.createElementNS(svgNS, "g");
        g.setAttribute("transform", "translate(50,50)");
        svg.appendChild(g);
        // Calculate pie segments
        let startAngle = 0;
        typeData.forEach((item) => {
            const percentage = (item.count / totalEvents) * 100;
            const angleSize = (percentage / 100) * 360;
            const endAngle = startAngle + angleSize;
            // Convert angles to radians
            const startRad = ((startAngle - 90) * Math.PI) / 180;
            const endRad = ((endAngle - 90) * Math.PI) / 180;
            // Calculate coordinates
            const x1 = 40 * Math.cos(startRad);
            const y1 = 40 * Math.sin(startRad);
            const x2 = 40 * Math.cos(endRad);
            const y2 = 40 * Math.sin(endRad);
            // Create path for arc
            const path = document.createElementNS(svgNS, "path");
            // Determine if the arc is greater than 180 degrees
            const largeArcFlag = angleSize > 180 ? 1 : 0;
            // SVG path for an arc
            const d = [
                `M ${x1},${y1}`,
                `A 40,40 0 ${largeArcFlag},1 ${x2},${y2}`,
                `L 0,0`,
                `Z`, // Close path
            ].join(" ");
            path.setAttribute("d", d);
            path.setAttribute("fill", item.color);
            path.setAttribute("title", `${item.type}: ${item.count} (${percentage.toFixed(1)}%)`);
            g.appendChild(path);
            // Add legend item
            const legendItem = legendContainer.createEl("div", {
                cls: "chronica-legend-item",
            });
            // Color swatch
            const colorSwatch = legendItem.createEl("div", {
                cls: "chronica-legend-swatch",
            });
            colorSwatch.style.backgroundColor = item.color;
            // Text content with type and count
            const legendText = legendItem.createEl("div", {
                cls: "chronica-legend-text",
            });
            legendText.createEl("span", {
                cls: "chronica-legend-type",
                text: item.type,
            });
            legendText.createEl("span", {
                cls: "chronica-legend-count",
                text: `${item.count} (${percentage.toFixed(1)}%)`,
            });
            // Update for next segment
            startAngle = endAngle;
        });
        // Add inner circle for donut hole
        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", "0");
        circle.setAttribute("cy", "0");
        circle.setAttribute("r", "25");
        circle.setAttribute("fill", "var(--background-secondary)");
        g.appendChild(circle);
        // Add total count in the middle
        const totalText = document.createElementNS(svgNS, "text");
        totalText.setAttribute("x", "0");
        totalText.setAttribute("y", "0");
        totalText.setAttribute("text-anchor", "middle");
        totalText.setAttribute("dominant-baseline", "middle");
        totalText.setAttribute("fill", "var(--text-normal)");
        totalText.setAttribute("font-size", "12");
        totalText.setAttribute("font-weight", "bold");
        totalText.textContent = totalEvents.toString();
        g.appendChild(totalText);
        const totalLabel = document.createElementNS(svgNS, "text");
        totalLabel.setAttribute("x", "0");
        totalLabel.setAttribute("y", "12");
        totalLabel.setAttribute("text-anchor", "middle");
        totalLabel.setAttribute("dominant-baseline", "middle");
        totalLabel.setAttribute("fill", "var(--text-muted)");
        totalLabel.setAttribute("font-size", "6");
        totalLabel.textContent = "Events";
        g.appendChild(totalLabel);
        // ======== SEASONAL PATTERN ANALYSIS ========
        const seasonalCard = chartsGridContainer.createEl("div", {
            cls: "chronica-chart-card",
        });
        seasonalCard.createEl("h3", {
            cls: "chronica-chart-title",
            text: "Seasonal Patterns",
        });
        // Define seasons with their months and colors
        const seasons = [
            { name: "Winter", months: [11, 0, 1], color: "#90CAF9" },
            { name: "Spring", months: [2, 3, 4], color: "#A5D6A7" },
            { name: "Summer", months: [5, 6, 7], color: "#FFCC80" },
            { name: "Fall", months: [8, 9, 10], color: "#EF9A9A" }, // Sep, Oct, Nov
        ];
        // Count events by season
        const seasonCounts = seasons.map((season) => {
            let count = 0;
            allEvents.forEach((event) => {
                const { year, week } = parseWeekKey(event.weekKey);
                if (year <= 0)
                    return;
                // Estimate month from week number (approximate)
                const eventDate = new Date(year, 0, 1);
                eventDate.setDate(eventDate.getDate() + (week - 1) * 7);
                const month = eventDate.getMonth();
                if (season.months.includes(month)) {
                    count++;
                }
            });
            return { ...season, count };
        });
        // Create seasonal chart container
        const seasonalChartContainer = seasonalCard.createEl("div", {
            cls: "chronica-seasonal-chart-container",
        });
        // Create SVG for radar chart
        const seasonalSvg = document.createElementNS(svgNS, "svg");
        seasonalSvg.classList.add("chronica-seasonal-chart");
        // define true center and radius
        const SIZE = 300;
        const CENTER = SIZE / 2; // 150px
        const OUTER_RADIUS = 100; // your existing radius
        // set up your SVG coordinate space
        seasonalSvg.setAttribute("viewBox", `0 0 ${SIZE} ${SIZE}`);
        seasonalSvg.setAttribute("width", SIZE.toString());
        seasonalSvg.setAttribute("height", SIZE.toString());
        seasonalChartContainer.appendChild(seasonalSvg);
        // Find maximum count for scaling
        const maxSeasonCount = Math.max(...seasonCounts.map((s) => s.count), 1);
        const totalSeasonEvents = seasonCounts.reduce((sum, s) => sum + s.count, 0);
        if (totalSeasonEvents > 0) {
            // Create background circle
            const bgCircle = document.createElementNS(svgNS, "circle");
            bgCircle.setAttribute("cx", CENTER.toString());
            bgCircle.setAttribute("cy", CENTER.toString());
            bgCircle.setAttribute("r", OUTER_RADIUS.toString());
            bgCircle.setAttribute("fill", "none");
            bgCircle.setAttribute("stroke", "var(--background-modifier-border)");
            bgCircle.setAttribute("stroke-width", "1");
            bgCircle.setAttribute("opacity", "0.5");
            seasonalSvg.appendChild(bgCircle);
            // Create mid-level circle
            const midCircle = document.createElementNS(svgNS, "circle");
            midCircle.setAttribute("cx", CENTER.toString());
            midCircle.setAttribute("cy", CENTER.toString());
            midCircle.setAttribute("r", (OUTER_RADIUS / 2).toString());
            midCircle.setAttribute("fill", "none");
            midCircle.setAttribute("stroke", "var(--background-modifier-border)");
            midCircle.setAttribute("stroke-width", "1");
            midCircle.setAttribute("opacity", "0.3");
            seasonalSvg.appendChild(midCircle);
            // Create center point
            const centerPoint = document.createElementNS(svgNS, "circle");
            centerPoint.setAttribute("cx", CENTER.toString());
            centerPoint.setAttribute("cy", CENTER.toString());
            centerPoint.setAttribute("r", "3");
            centerPoint.setAttribute("fill", "var(--background-modifier-border)");
            seasonalSvg.appendChild(centerPoint);
            // Draw axis lines
            const axisPoints = [
                { x: CENTER, y: CENTER - OUTER_RADIUS },
                { x: CENTER + OUTER_RADIUS, y: CENTER },
                { x: CENTER, y: CENTER + OUTER_RADIUS },
                { x: CENTER - OUTER_RADIUS, y: CENTER }, // Fall
            ];
            // Create axes
            for (let i = 0; i < 4; i++) {
                const axis = document.createElementNS(svgNS, "line");
                axis.setAttribute("x1", CENTER.toString());
                axis.setAttribute("y1", CENTER.toString());
                axis.setAttribute("x2", axisPoints[i].x.toString());
                axis.setAttribute("y2", axisPoints[i].y.toString());
                axis.setAttribute("stroke", "var(--background-modifier-border)");
                axis.setAttribute("stroke-width", "1");
                axis.setAttribute("opacity", "0.5");
                seasonalSvg.appendChild(axis);
            }
            // Create season labels with better positioning
            const seasonLabels = ["Winter", "Spring", "Summer", "Fall"];
            const labelPoints = [
                { x: CENTER, y: CENTER - OUTER_RADIUS - 20 },
                { x: CENTER + OUTER_RADIUS + 30, y: CENTER },
                { x: CENTER, y: CENTER + OUTER_RADIUS + 20 },
                { x: CENTER - OUTER_RADIUS - 20, y: CENTER }, // Fall (left)
            ];
            for (let i = 0; i < 4; i++) {
                const label = document.createElementNS(svgNS, "text");
                label.setAttribute("x", labelPoints[i].x.toString());
                label.setAttribute("y", labelPoints[i].y.toString());
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("dominant-baseline", "middle");
                label.setAttribute("fill", "var(--text-normal)");
                label.setAttribute("font-size", "12");
                label.textContent = seasonLabels[i];
                seasonalSvg.appendChild(label);
            }
            // Calculate radar points
            const radarPoints = seasonCounts.map((season, i) => {
                const normalizedValue = season.count / maxSeasonCount;
                const radius = normalizedValue * OUTER_RADIUS;
                const angle = Math.PI / 2 - (i * Math.PI) / 2; // start at top, clockwise
                const x = CENTER + radius * Math.cos(angle);
                const y = CENTER - radius * Math.sin(angle);
                return {
                    x,
                    y,
                    value: season.count,
                    percentage: (season.count / totalSeasonEvents) * 100,
                };
            });
            // Create radar polygon
            if (radarPoints.some((p) => p.value > 0)) {
                const polygon = document.createElementNS(svgNS, "polygon");
                // Build points string
                const pointsStr = radarPoints.map((p) => `${p.x},${p.y}`).join(" ");
                polygon.setAttribute("points", pointsStr);
                polygon.setAttribute("fill", "rgba(102, 126, 234, 0.5)");
                polygon.setAttribute("stroke", "var(--interactive-accent)");
                polygon.setAttribute("stroke-width", "2");
                seasonalSvg.appendChild(polygon);
                // Add data points and labels
                radarPoints.forEach((point, i) => {
                    // Always add the points for all four seasons regardless of value
                    // Add dot
                    const dot = document.createElementNS(svgNS, "circle");
                    dot.setAttribute("cx", point.x.toString());
                    dot.setAttribute("cy", point.y.toString());
                    dot.setAttribute("r", "6");
                    dot.setAttribute("fill", seasons[i].color);
                    dot.setAttribute("stroke", "var(--background-primary)");
                    dot.setAttribute("stroke-width", "1");
                    seasonalSvg.appendChild(dot);
                    // Calculate better positions for labels based on season
                    let labelX = 0;
                    let labelY = 0;
                    let pctX = 0;
                    let pctY = 0;
                    switch (i) {
                        case 0: // Winter (top)
                            labelX = point.x;
                            labelY = point.y - 20;
                            pctX = labelX;
                            pctY = labelY - 15;
                            break;
                        case 1: // Spring (right)
                            labelX = point.x;
                            labelY = point.y - 10;
                            pctX = labelX;
                            pctY = labelY - 15;
                            break;
                        case 2: // Summer (bottom)
                            labelX = point.x;
                            labelY = point.y + 20;
                            pctX = labelX;
                            pctY = labelY + 15;
                            break;
                        case 3: // Fall (left)
                            labelX = point.x - 30;
                            labelY = point.y;
                            pctX = labelX;
                            pctY = labelY - 15;
                            break;
                    }
                    // Add percentage (always show)
                    const pctLabel = document.createElementNS(svgNS, "text");
                    pctLabel.setAttribute("x", pctX.toString());
                    pctLabel.setAttribute("y", pctY.toString());
                    pctLabel.setAttribute("text-anchor", "middle");
                    pctLabel.setAttribute("dominant-baseline", "middle");
                    pctLabel.setAttribute("fill", "var(--text-muted)");
                    pctLabel.setAttribute("font-size", "10");
                    pctLabel.textContent = `${Math.round(point.percentage)}%`;
                    seasonalSvg.appendChild(pctLabel);
                    // Add raw count with Spring/Fall moved under the percentage
                    const countLabel = document.createElementNS(svgNS, "text");
                    // default: place under the percent
                    let countX = pctX;
                    let countY = pctY + 12;
                    if (i === 2) {
                        // Summer: override to place above
                        countY = pctY - 12;
                    }
                    countLabel.setAttribute("x", countX.toString());
                    countLabel.setAttribute("y", countY.toString());
                    countLabel.setAttribute("text-anchor", "middle");
                    countLabel.setAttribute("dominant-baseline", "middle");
                    countLabel.setAttribute("fill", "var(--text-normal)");
                    countLabel.setAttribute("font-size", "10");
                    countLabel.textContent = point.value.toString();
                    seasonalSvg.appendChild(countLabel);
                });
            }
            // Add total in center
            const totalContainer = document.createElementNS(svgNS, "circle");
            totalContainer.setAttribute("cx", CENTER.toString());
            totalContainer.setAttribute("cy", CENTER.toString());
            totalContainer.setAttribute("r", (OUTER_RADIUS / 4).toString()); // 25 if OUTER_RADIUS=100
            totalContainer.setAttribute("fill", "var(--background-secondary)");
            seasonalSvg.appendChild(totalContainer);
            const totalText = document.createElementNS(svgNS, "text");
            totalText.setAttribute("x", CENTER.toString());
            totalText.setAttribute("y", (CENTER - 5).toString());
            totalText.setAttribute("text-anchor", "middle");
            totalText.setAttribute("dominant-baseline", "middle");
            totalText.setAttribute("fill", "var(--text-normal)");
            totalText.setAttribute("font-size", "16");
            totalText.setAttribute("font-weight", "bold");
            totalText.textContent = totalSeasonEvents.toString();
            seasonalSvg.appendChild(totalText);
            const eventsLabel = document.createElementNS(svgNS, "text");
            eventsLabel.setAttribute("x", CENTER.toString());
            eventsLabel.setAttribute("y", (CENTER + 10).toString());
            eventsLabel.setAttribute("text-anchor", "middle");
            eventsLabel.setAttribute("dominant-baseline", "middle");
            eventsLabel.setAttribute("fill", "var(--text-muted)");
            eventsLabel.setAttribute("font-size", "10");
            eventsLabel.textContent = "Events";
            seasonalSvg.appendChild(eventsLabel);
        }
        else {
            // Show empty state
            const emptyText = document.createElementNS(svgNS, "text");
            emptyText.setAttribute("x", CENTER.toString());
            emptyText.setAttribute("y", CENTER.toString());
            emptyText.setAttribute("text-anchor", "middle");
            emptyText.setAttribute("dominant-baseline", "middle");
            emptyText.setAttribute("fill", "var(--text-muted)");
            emptyText.setAttribute("font-size", "14");
            emptyText.textContent = "No events to analyze";
            seasonalSvg.appendChild(emptyText);
        }
        // ======== FUTURE PLANNING HORIZON CHART ========
        const futurePlanningCard = chartsGridContainer.createEl("div", {
            cls: "chronica-chart-card chronica-full-width",
        });
        futurePlanningCard.createEl("h3", {
            cls: "chronica-chart-title",
            text: "Future Planning Horizon",
        });
        // Filter for future events only
        const futureEvents = allEvents.filter((event) => {
            const { year, week } = parseWeekKey(event.weekKey);
            if (year <= 0)
                return false;
            // Create date from week key
            const eventDate = new Date(year, 0, 1);
            eventDate.setDate(eventDate.getDate() + (week - 1) * 7);
            return eventDate > now;
        });
        // If no future events, show empty state
        if (futureEvents.length === 0) {
            futurePlanningCard.createEl("div", {
                cls: "chronica-empty-state",
                text: "No future events planned yet",
            });
        }
        else {
            // Group future events by time horizon
            const horizons = {
                "Next Month": 30,
                "1-3 Months": 90,
                "3-6 Months": 180,
                "6-12 Months": 365,
                "1-2 Years": 730,
                "2+ Years": Infinity,
            };
            const horizonCounts = {};
            Object.keys(horizons).forEach((key) => (horizonCounts[key] = 0));
            // Count events for each horizon
            futureEvents.forEach((event) => {
                const { year, week } = parseWeekKey(event.weekKey);
                // Create date from week key
                const eventDate = new Date(year, 0, 1);
                eventDate.setDate(eventDate.getDate() + (week - 1) * 7);
                // Calculate days from now
                const daysFromNow = Math.ceil((eventDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
                // Find appropriate horizon
                for (const [horizon, days] of Object.entries(horizons)) {
                    if (daysFromNow <= days) {
                        horizonCounts[horizon]++;
                        break;
                    }
                }
            });
            // Create horizons chart container
            const horizonsContainer = futurePlanningCard.createEl("div", {
                cls: "chronica-horizons-container",
            });
            // Sort horizons by timeframe
            const sortedHorizons = Object.keys(horizonCounts).filter((h) => horizonCounts[h] > 0);
            // Find maximum for scaling
            const maxHorizonCount = Math.max(...Object.values(horizonCounts), 1);
            // Create bars for each horizon
            sortedHorizons.forEach((horizon) => {
                const count = horizonCounts[horizon];
                if (count === 0)
                    return;
                const horizonRow = horizonsContainer.createEl("div", {
                    cls: "chronica-horizon-row",
                });
                horizonRow.createEl("div", {
                    cls: "chronica-horizon-label",
                    text: horizon,
                });
                const barContainer = horizonRow.createEl("div", {
                    cls: "chronica-horizon-bar-container",
                });
                const bar = barContainer.createEl("div", {
                    cls: "chronica-horizon-bar",
                });
                // Scale the bar width
                bar.style.width = `${(count / maxHorizonCount) * 100}%`;
                // Add count on the bar
                barContainer.createEl("div", {
                    cls: "chronica-horizon-count",
                    text: count.toString(),
                });
            });
            // Add summary at the bottom
            futurePlanningCard.createEl("div", {
                cls: "chronica-horizon-summary",
                text: `${futureEvents.length} events planned in the future`,
            });
        }
        // ======== MONTHLY DISTRIBUTION CHART ========
        const monthlyChartCard = chartsGridContainer.createEl("div", {
            cls: "chronica-chart-card chronica-full-width",
        });
        monthlyChartCard.createEl("h3", {
            cls: "chronica-chart-title",
            text: "Event Distribution by Month",
        });
        // Count events by month
        const eventsByMonth = Array(12).fill(0);
        allEvents.forEach((event) => {
            // Simple approximation of month from week number
            const { year, week } = parseWeekKey(event.weekKey);
            if (year > 0) {
                // Estimate month based on week number (very approximate)
                const monthIndex = Math.min(11, Math.floor((week - 1) / 4.34)); // ~4.34 weeks per month
                if (monthIndex >= 0 && monthIndex < 12) {
                    eventsByMonth[monthIndex]++;
                }
            }
        });
        // Create monthly chart container
        const monthlyChartContainer = monthlyChartCard.createEl("div", {
            cls: "chronica-monthly-chart-container",
        });
        // Month names
        const monthNames = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
        ];
        // Get maximum for scaling
        const maxMonthlyEvents = Math.max(...eventsByMonth, 1);
        // Create month bars
        monthNames.forEach((month, index) => {
            const count = eventsByMonth[index];
            const barHeight = Math.max(5, (count / maxMonthlyEvents) * 100);
            const barContainer = monthlyChartContainer.createEl("div", {
                cls: "chronica-bar-wrapper chronica-month-bar-wrapper",
            });
            const bar = barContainer.createEl("div", {
                cls: "chronica-bar chronica-month-bar",
            });
            bar.style.height = `${barHeight}%`;
            // Add value above bar
            barContainer.createEl("div", {
                cls: "chronica-bar-value",
                text: count > 0 ? count.toString() : "",
            });
            // Add month label below bar
            barContainer.createEl("div", {
                cls: "chronica-bar-label",
                text: month,
            });
            // Highlight current month
            if (index === now.getMonth()) {
                barContainer.addClass("chronica-current-period");
                bar.addClass("chronica-current-bar");
            }
            // Set tooltip
            barContainer.setAttribute("title", `${month}: ${count} events`);
        });
    }
    /**
     * Apply styling for events to a cell
     * @param cell - Cell element to style
     * @param weekKey - Week key to check for events (YYYY-WXX)
     * @returns Whether an event was applied to this cell
     */
    applyEventStyling(cell, weekKey) {
        // Check if we have an event in the note frontmatter (new functionality)
        const checkNoteEvent = async () => {
            try {
                const eventData = await this.plugin.getEventFromNote(weekKey);
                if (eventData && eventData.event) {
                    // Apply styling based on note frontmatter
                    cell.classList.add("event");
                    cell.classList.add("major-life-event");
                    // Add specific event type class based on type
                    switch (eventData.type) {
                        case "Major Life":
                            cell.classList.add("major-life-event");
                            break;
                        case "Travel":
                            cell.classList.add("travel-event");
                            break;
                        case "Relationship":
                            cell.classList.add("relationship-event");
                            break;
                        case "Education/Career":
                            cell.classList.add("education-career-event");
                            break;
                    }
                    // Apply color if specified in frontmatter
                    if (eventData.color) {
                        cell.style.backgroundColor = eventData.color;
                        cell.style.border = `2px solid ${eventData.color}`;
                    }
                    else {
                        // Default color based on type
                        let defaultColor = "#4CAF50"; // Default to green (Major Life)
                        switch (eventData.type) {
                            case "Major Life":
                                defaultColor = "#4CAF50";
                                break;
                            case "Travel":
                                defaultColor = "#2196F3";
                                break;
                            case "Relationship":
                                defaultColor = "#E91E63";
                                break;
                            case "Education/Career":
                                defaultColor = "#D2B55B";
                                break;
                            default:
                                // Check if it's a custom type
                                const customType = this.plugin.settings.customEventTypes.find((t) => t.name === eventData.type);
                                if (customType) {
                                    defaultColor = customType.color;
                                }
                        }
                        cell.style.backgroundColor = defaultColor;
                        cell.style.border = `2px solid ${defaultColor}`;
                    }
                    // Build tooltip
                    const eventName = eventData.name || eventData.event;
                    const eventDesc = eventData.description
                        ? `: ${eventData.description}`
                        : "";
                    const prevTitle = cell.getAttribute("title") || "";
                    // Include date range info if present
                    let dateInfo = "";
                    if (eventData.startDate && eventData.endDate) {
                        dateInfo = ` (${eventData.startDate} to ${eventData.endDate})`;
                    }
                    else if (eventData.startDate) {
                        dateInfo = ` (${eventData.startDate})`;
                    }
                    cell.setAttribute("title", `${eventName}${eventDesc}${dateInfo}${prevTitle ? "\n" + prevTitle : ""}`);
                    return true;
                }
                return false;
            }
            catch (error) {
                console.log("Error checking note event:", error);
                return false;
            }
        };
        // Schedule the async check to happen soon (we can't make this method async without breaking a lot of code)
        setTimeout(async () => {
            if (await checkNoteEvent()) {
                // Force a refresh of any display properties
                const currBg = cell.style.backgroundColor;
                cell.style.backgroundColor = "transparent";
                cell.style.backgroundColor = currBg;
            }
        }, 0);
        // Continue with existing functionality (fallback) - helper to check for events and apply styling
        const applyEventStyle = (events, defaultColor, defaultDesc) => {
            // First, handle single-day events (format: weekKey:description)
            // Single‑week events (format: weekKey:description)
            const singleEvents = events.filter((e) => {
                const parts = e.split(":");
                return parts.length === 2 && parts[0].includes("W");
            });
            for (const ev of singleEvents) {
                const [eventWeekKey, description] = ev.split(":");
                // Direct string match: if the event's weekKey equals this cell's weekKey
                if (eventWeekKey === weekKey) {
                    // Apply styles
                    cell.classList.add("event");
                    cell.style.backgroundColor = defaultColor;
                    cell.style.border = `2px solid ${defaultColor}`;
                    // Build tooltip
                    const eventDesc = description || defaultDesc;
                    const prevTitle = cell.getAttribute("title") || "";
                    cell.setAttribute("title", `${eventDesc} (${eventWeekKey})\n${prevTitle}`);
                    return true;
                }
            }
            // Next, handle range events (format: startWeek:endWeek:description)
            const rangeEvents = events.filter((e) => {
                const parts = e.split(":");
                return (parts.length >= 3 && parts[0].includes("W") && parts[1].includes("W"));
            });
            for (const rangeEvent of rangeEvents) {
                const [startWeekKey, endWeekKey, description] = rangeEvent.split(":");
                // Skip if the format is invalid
                if (!startWeekKey || !endWeekKey)
                    continue;
                try {
                    // Parse the week numbers
                    const startYear = parseInt(startWeekKey.split("-W")[0], 10);
                    const startWeek = parseInt(startWeekKey.split("-W")[1], 10);
                    const endYear = parseInt(endWeekKey.split("-W")[0], 10);
                    const endWeek = parseInt(endWeekKey.split("-W")[1], 10);
                    // Parse current cell week
                    const cellYear = parseInt(weekKey.split("-W")[0], 10);
                    const cellWeek = parseInt(weekKey.split("-W")[1], 10);
                    // Create actual dates to compare
                    const startDate = new Date(startYear, 0, 1);
                    startDate.setDate(startDate.getDate() + (startWeek - 1) * 7);
                    const endDate = new Date(endYear, 0, 1);
                    endDate.setDate(endDate.getDate() + (endWeek - 1) * 7 + 6); // Add 6 to include full end week
                    const cellDate = new Date(cellYear, 0, 1);
                    cellDate.setDate(cellDate.getDate() + (cellWeek - 1) * 7);
                    // Check if current week falls within the range using actual dates
                    const isInRange = cellDate >= startDate && cellDate <= endDate;
                    if (isInRange) {
                        // Apply styles
                        cell.addClass("event");
                        cell.style.backgroundColor = defaultColor;
                        cell.style.borderColor = defaultColor;
                        cell.style.borderWidth = "2px";
                        cell.style.borderStyle = "solid";
                        // Add specific event type class based on color
                        if (defaultColor === "#4CAF50") {
                            cell.addClass("major-life-event");
                        }
                        else if (defaultColor === "#2196F3") {
                            cell.addClass("travel-event");
                        }
                        else if (defaultColor === "#E91E63") {
                            cell.addClass("relationship-event");
                        }
                        else if (defaultColor === "#D2B55B") {
                            cell.addClass("education-career-event");
                        }
                        const eventDesc = description || defaultDesc;
                        const currentTitle = cell.getAttribute("title") || "";
                        cell.setAttribute("title", `${eventDesc} (${startWeekKey} to ${endWeekKey})\n${currentTitle}`);
                        return true;
                    }
                }
                catch (error) {
                    console.error("Error processing range event:", rangeEvent, error);
                }
            }
            for (const rangeEvent of rangeEvents) {
                const [startWeekKey, endWeekKey, description] = rangeEvent.split(":");
                // Skip if the format is invalid
                if (!startWeekKey || !endWeekKey)
                    continue;
                // Parse the week numbers
                const startYear = parseInt(startWeekKey.split("-W")[0], 10);
                const startWeek = parseInt(startWeekKey.split("-W")[1], 10);
                const endYear = parseInt(endWeekKey.split("-W")[0], 10);
                const endWeek = parseInt(endWeekKey.split("-W")[1], 10);
                // Parse current cell week
                const cellYear = parseInt(weekKey.split("-W")[0], 10);
                const cellWeek = parseInt(weekKey.split("-W")[1], 10);
                // Create actual dates to compare
                const startDate = new Date(startYear, 0, 1);
                startDate.setDate(startDate.getDate() + (startWeek - 1) * 7);
                const endDate = new Date(endYear, 0, 1);
                endDate.setDate(endDate.getDate() + (endWeek - 1) * 7 + 6); // Add 6 to include full end week
                const cellDate = new Date(cellYear, 0, 1);
                cellDate.setDate(cellDate.getDate() + (cellWeek - 1) * 7);
                // Check if current week falls within the range using actual dates
                const isInRange = cellDate >= startDate && cellDate <= endDate;
                if (isInRange) {
                    // Apply styles
                    cell.addClass("event");
                    cell.style.backgroundColor = defaultColor;
                    cell.style.borderColor = defaultColor;
                    cell.style.borderWidth = "2px";
                    cell.style.borderStyle = "solid";
                    const eventDesc = description || defaultDesc;
                    const currentTitle = cell.getAttribute("title") || "";
                    cell.setAttribute("title", `${eventDesc} (${startWeekKey} to ${endWeekKey})\n${currentTitle}`);
                    return true;
                }
            }
            return false;
        };
        // Apply event styling for each event type
        const hasGreenEvent = applyEventStyle(this.plugin.settings.greenEvents, "#4CAF50", "Major Life Event");
        if (hasGreenEvent)
            return true;
        const hasBlueEvent = applyEventStyle(this.plugin.settings.blueEvents, "#2196F3", "Travel");
        if (hasBlueEvent)
            return true;
        const hasPinkEvent = applyEventStyle(this.plugin.settings.pinkEvents, "#E91E63", "Relationship");
        if (hasPinkEvent)
            return true;
        const hasPurpleEvent = applyEventStyle(this.plugin.settings.purpleEvents, "#D2B55B", "Education/Career");
        if (hasPurpleEvent)
            return true;
        // Only check custom events if no built-in event was found
        if (this.plugin.settings.customEvents) {
            for (const [typeName, events] of Object.entries(this.plugin.settings.customEvents)) {
                const customType = this.plugin.settings.customEventTypes.find((type) => type.name === typeName);
                if (customType && events.length > 0) {
                    const hasCustomEvent = applyEventStyle(events, customType.color, typeName);
                    if (hasCustomEvent)
                        return true;
                }
            }
        }
        // Highlight future events within next 6 months
        const now = new Date();
        const cellDate = new Date();
        const [cellYearStr, weekNumStr] = weekKey.split("-W");
        cellDate.setFullYear(parseInt(cellYearStr, 10));
        cellDate.setDate(1 + (parseInt(weekNumStr, 10) - 1) * 7);
        if (cellDate > now &&
            cellDate < new Date(now.getTime() + 6 * 30 * 24 * 60 * 60 * 1000) &&
            cell.classList.contains("event")) {
            cell.addClass("future-event-highlight");
        }
        // Apply filled week styling if applicable
        if (this.plugin.settings.filledWeeks.includes(weekKey) &&
            weekKey !== this.plugin.getWeekKeyFromDate(new Date())) {
            cell.addClass("filled-week");
            // Only change color if no event is on this week
            if (!cell.classList.contains("event")) {
                cell.style.backgroundColor = "#8bc34a"; // Light green for filled weeks
            }
        }
        return false;
    }
}
// -----------------------------------------------------------------------
// EVENT TYPES MODAL CLASS
// -----------------------------------------------------------------------
/**
 * Modal for managing custom event types
 */
class ManageEventTypesModal extends obsidian.Modal {
    /** Reference to the main plugin */
    plugin;
    /**
     * Create a new event types modal
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     */
    constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
    }
    /**
     * Build the modal UI when opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Manage Event Types" });
        // Section for adding a new event type
        const addSection = contentEl.createDiv({ cls: "event-type-add-section" });
        addSection.createEl("h3", { text: "Add New Event Type" });
        const nameInput = addSection.createEl("input", {
            type: "text",
            placeholder: "Event Type Name",
        });
        const colorInput = addSection.createEl("input", {
            type: "color",
            value: "#FF9800",
        });
        const addButton = addSection.createEl("button", {
            text: "Add Type",
            cls: "add-type-button",
        });
        addButton.addEventListener("click", () => {
            const name = nameInput.value.trim();
            if (!name) {
                new obsidian.Notice("Please enter a name for the event type");
                return;
            }
            if (this.plugin.settings.customEventTypes.some((type) => type.name === name)) {
                new obsidian.Notice("An event type with this name already exists");
                return;
            }
            this.plugin.settings.customEventTypes.push({
                name: name,
                color: colorInput.value,
            });
            this.plugin.settings.customEvents[name] = [];
            this.plugin.saveSettings().then(() => {
                new obsidian.Notice(`Event type "${name}" added`);
                this.renderExistingTypes(contentEl);
                nameInput.value = "";
            });
        });
        // Section for listing existing custom types
        const existingSection = contentEl.createDiv({
            cls: "event-type-existing-section",
        });
        existingSection.createEl("h3", { text: "Existing Event Types" });
        this.renderExistingTypes(existingSection);
        // Close button
        const closeButton = contentEl.createEl("button", {
            text: "Close",
            cls: "close-button",
        });
        closeButton.addEventListener("click", () => {
            this.close();
            this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
                const view = leaf.view;
                view.renderView();
            });
        });
    }
    /**
     * Render list of existing event types
     * @param container - Container element
     */
    renderExistingTypes(container) {
        // Remove existing list if present
        const typesList = container.querySelector(".existing-types-list");
        if (typesList)
            typesList.remove();
        const newList = container.createEl("div", { cls: "existing-types-list" });
        // Built-in types section
        newList.createEl("p", {
            text: "Built-in types (cannot be edited)",
            cls: "built-in-note",
        });
        const builtInTypes = [
            { name: "Major Life", color: "#4CAF50" },
            { name: "Travel", color: "#2196F3" },
            { name: "Relationship", color: "#E91E63" },
            { name: "Education/Career", color: "#D2B55B" },
        ];
        for (const type of builtInTypes) {
            const typeItem = newList.createEl("div", {
                cls: "event-type-item built-in",
            });
            const colorBox = typeItem.createEl("span", { cls: "event-type-color" });
            colorBox.style.backgroundColor = type.color;
            typeItem.createEl("span", { text: type.name, cls: "event-type-name" });
        }
        // Custom types section
        if (this.plugin.settings.customEventTypes.length > 0) {
            newList.createEl("p", {
                text: "Your custom types",
                cls: "custom-types-note",
            });
            for (const type of this.plugin.settings.customEventTypes) {
                const typeItem = newList.createEl("div", {
                    cls: "event-type-item custom",
                });
                const colorBox = typeItem.createEl("span", { cls: "event-type-color" });
                colorBox.style.backgroundColor = type.color;
                typeItem.createEl("span", { text: type.name, cls: "event-type-name" });
                // Edit button
                const editButton = typeItem.createEl("button", {
                    text: "Edit",
                    cls: "edit-type-button",
                });
                editButton.addEventListener("click", () => {
                    this.showEditTypeModal(type);
                });
                // Delete button
                const deleteButton = typeItem.createEl("button", {
                    text: "Delete",
                    cls: "delete-type-button",
                });
                deleteButton.addEventListener("click", () => {
                    if (confirm(`Are you sure you want to delete the event type "${type.name}"? All events of this type will also be deleted.`)) {
                        this.plugin.settings.customEventTypes =
                            this.plugin.settings.customEventTypes.filter((t) => t.name !== type.name);
                        delete this.plugin.settings.customEvents[type.name];
                        this.plugin.saveSettings().then(() => {
                            new obsidian.Notice(`Event type "${type.name}" deleted`);
                            this.renderExistingTypes(container);
                        });
                    }
                });
            }
        }
        else {
            newList.createEl("p", {
                text: "You haven't created any custom event types yet",
                cls: "no-custom-types",
            });
        }
    }
    /**
     * Show modal for editing an event type
     * @param type - Custom event type to edit
     */
    showEditTypeModal(type) {
        const modal = new obsidian.Modal(this.app);
        modal.titleEl.setText(`Edit Event Type: ${type.name}`);
        const contentEl = modal.contentEl;
        // Name field
        const nameContainer = contentEl.createDiv({ cls: "edit-name-container" });
        const nameLabel = nameContainer.createEl("label");
        nameLabel.textContent = "Name";
        nameLabel.htmlFor = "edit-type-name";
        const nameInput = nameContainer.createEl("input");
        nameInput.type = "text";
        nameInput.value = type.name;
        nameInput.id = "edit-type-name";
        // Color field
        const colorContainer = contentEl.createDiv({ cls: "edit-color-container" });
        const colorLabel = colorContainer.createEl("label");
        colorLabel.textContent = "Color";
        colorLabel.htmlFor = "edit-type-color";
        const colorInput = colorContainer.createEl("input");
        colorInput.type = "color";
        colorInput.value = type.color;
        colorInput.id = "edit-type-color";
        // Save button
        const saveButton = contentEl.createEl("button", {
            text: "Save Changes",
            cls: "save-edit-button",
        });
        saveButton.addEventListener("click", () => {
            const newName = nameInput.value.trim();
            if (!newName) {
                new obsidian.Notice("Please enter a name for the event type");
                return;
            }
            if (newName !== type.name &&
                this.plugin.settings.customEventTypes.some((t) => t.name === newName)) {
                new obsidian.Notice("An event type with this name already exists");
                return;
            }
            // Update name reference in events if changed
            if (newName !== type.name) {
                this.plugin.settings.customEvents[newName] =
                    this.plugin.settings.customEvents[type.name] || [];
                delete this.plugin.settings.customEvents[type.name];
            }
            // Update event type
            const typeIndex = this.plugin.settings.customEventTypes.findIndex((t) => t.name === type.name);
            if (typeIndex !== -1) {
                this.plugin.settings.customEventTypes[typeIndex] = {
                    name: newName,
                    color: colorInput.value,
                };
                this.plugin.saveSettings().then(() => {
                    new obsidian.Notice(`Event type updated to "${newName}"`);
                    modal.close();
                    this.renderExistingTypes(this.contentEl);
                });
            }
        });
        // Cancel button
        const cancelButton = contentEl.createEl("button", {
            text: "Cancel",
            cls: "cancel-edit-button",
        });
        cancelButton.addEventListener("click", () => {
            modal.close();
        });
        modal.open();
    }
    /**
     * Clean up on modal close
     */
    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}
// -----------------------------------------------------------------------
// SETTINGS TAB CLASS
// -----------------------------------------------------------------------
/**
 * Settings tab for configuring the plugin
 */
class ChronosSettingTab extends obsidian.PluginSettingTab {
    /** Reference to the main plugin */
    plugin;
    /**
     * Create a new settings tab
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     */
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    /**
     * Build the settings UI
     */
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h1", { text: "Chronica Timeline Settings" });
        containerEl.createEl("p", {
            text: "Customize your life timeline visualization.",
        });
        // Birthday setting
        new obsidian.Setting(containerEl)
            .setName("Birthday")
            .setDesc("Your date of birth (YYYY-MM-DD)")
            .addText((text) => text
            .setPlaceholder("1990-01-01")
            .setValue(this.plugin.settings.birthday)
            .onChange(async (value) => {
            this.plugin.settings.birthday = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Lifespan setting
        new obsidian.Setting(containerEl)
            .setName("Lifespan")
            .setDesc("Maximum age in years to display")
            .addSlider((slider) => slider
            .setLimits(50, 120, 5)
            .setValue(this.plugin.settings.lifespan)
            .setDynamicTooltip()
            .onChange(async (value) => {
            this.plugin.settings.lifespan = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Notes folder setting
        new obsidian.Setting(containerEl)
            .setName("Notes folder")
            .setDesc("Select the folder where your weekly notes live")
            .addSearch((search) => {
            search
                .setPlaceholder("Pick a folder…")
                .setValue(this.plugin.settings.notesFolder)
                .onChange(async (value) => {
                this.plugin.settings.notesFolder = value;
                await this.plugin.saveSettings();
            });
            // Pass the plugin instance to FolderSuggest
            new FolderSuggest(this.app, search.inputEl, this.plugin);
        });
        // Quote setting
        new obsidian.Setting(containerEl)
            .setName("Footer Quote")
            .setDesc("Inspirational quote to display at the bottom")
            .addText((text) => text
            .setPlaceholder("the only true luxury is time.")
            .setValue(this.plugin.settings.quote)
            .onChange(async (value) => {
            this.plugin.settings.quote = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Marker visibility section
        containerEl.createEl("h3", { text: "Marker Visibility" });
        // Decade markers setting
        new obsidian.Setting(containerEl)
            .setName("Decade Markers")
            .setDesc("Show decade markers along the top (0, 10, 20, ...)")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showDecadeMarkers)
            .onChange(async (value) => {
            this.plugin.settings.showDecadeMarkers = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Week markers setting
        new obsidian.Setting(containerEl)
            .setName("Week Markers")
            .setDesc("Show week markers along the left (10, 20, 30, ...)")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showWeekMarkers)
            .onChange(async (value) => {
            this.plugin.settings.showWeekMarkers = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Month markers setting
        new obsidian.Setting(containerEl)
            .setName("Month Markers")
            .setDesc("Show month markers along the left side (Jan, Feb, Mar, ...)")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showMonthMarkers)
            .onChange(async (value) => {
            this.plugin.settings.showMonthMarkers = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
            // Show/hide month marker frequency setting based on toggle state
            const freqSetting = containerEl.querySelector(".month-marker-frequency");
            if (freqSetting) {
                freqSetting.style.display = value
                    ? "flex"
                    : "none";
            }
        }));
        // Month marker frequency setting
        const freqSetting = new obsidian.Setting(containerEl)
            .setName("Month Marker Frequency")
            .setDesc("Choose how often month markers appear")
            .setClass("month-marker-frequency")
            .addDropdown((dropdown) => {
            dropdown
                .addOption("all", "Every Month")
                .addOption("quarter", "Every Quarter (Jan, Apr, Jul, Oct)")
                .addOption("half-year", "Every Half Year (Jan, Jul)")
                .addOption("year", "Every Year (Jan only)")
                .setValue(this.plugin.settings.monthMarkerFrequency)
                .onChange(async (value) => {
                this.plugin.settings.monthMarkerFrequency = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            });
        });
        // Hide frequency setting if month markers are disabled
        if (!this.plugin.settings.showMonthMarkers) {
            freqSetting.settingEl.style.display = "none";
        }
        // Color settings section
        containerEl.createEl("h3", { text: "Colors" });
        // Past cells color
        new obsidian.Setting(containerEl)
            .setName("Past Weeks Color")
            .setDesc("Color for weeks that have passed")
            .addColorPicker((colorPicker) => colorPicker
            .setValue(this.plugin.settings.pastCellColor)
            .onChange(async (value) => {
            this.plugin.settings.pastCellColor = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Present cell color
        new obsidian.Setting(containerEl)
            .setName("Current Week Color")
            .setDesc("Color for the current week")
            .addColorPicker((colorPicker) => colorPicker
            .setValue(this.plugin.settings.presentCellColor)
            .onChange(async (value) => {
            this.plugin.settings.presentCellColor = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Future cells color
        new obsidian.Setting(containerEl)
            .setName("Future Weeks Color")
            .setDesc("Color for weeks in the future")
            .addColorPicker((colorPicker) => colorPicker
            .setValue(this.plugin.settings.futureCellColor)
            .onChange(async (value) => {
            this.plugin.settings.futureCellColor = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Find the "Week Filling Options" section in your code
        containerEl.createEl("h3", { text: "Week Filling Options" });
        // Replace the existing toggles with this single toggle that handles both modes
        new obsidian.Setting(containerEl)
            .setName("Enable Auto-Fill")
            .setDesc("When enabled, automatically marks weeks as completed on a specific day. When disabled, you can manually mark weeks by right-clicking them.")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.enableAutoFill)
            .onChange(async (value) => {
            this.plugin.settings.enableAutoFill = value;
            // If auto-fill is enabled, manual fill should be disabled
            this.plugin.settings.enableManualFill = !value;
            await this.plugin.saveSettings();
            // Show/hide day selector based on toggle state
            const daySelector = containerEl.querySelector(".auto-fill-day-selector");
            if (daySelector) {
                daySelector.style.display = value
                    ? "flex"
                    : "none";
            }
            // Add status indicator text
            const statusIndicator = containerEl.querySelector(".fill-mode-status");
            if (statusIndicator) {
                statusIndicator.textContent = value
                    ? "Auto-fill is active. Weeks will be filled automatically."
                    : "Manual fill is active. Right-click on future weeks to mark them as filled.";
            }
            else {
                const statusEl = containerEl.createEl("div", {
                    cls: "fill-mode-status",
                    text: value
                        ? "Auto-fill is active. Weeks will be filled automatically."
                        : "Manual fill is active. Right-click on future weeks to mark them as filled.",
                });
                statusEl.style.fontStyle = "italic";
                statusEl.style.marginTop = "5px";
                statusEl.style.color = "var(--text-muted)";
            }
            this.refreshAllViews();
        }));
        // Auto-fill day selector (keep this)
        const daySelector = new obsidian.Setting(containerEl)
            .setName("Auto-Fill Day")
            .setDesc("Day of the week when auto-fill should occur")
            .setClass("auto-fill-day-selector")
            .addDropdown((dropdown) => {
            const days = [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ];
            days.forEach((day, index) => {
                dropdown.addOption(index.toString(), day);
            });
            dropdown
                .setValue(this.plugin.settings.autoFillDay.toString())
                .onChange(async (value) => {
                this.plugin.settings.autoFillDay = parseInt(value);
                await this.plugin.saveSettings();
            });
        });
        // Hide day selector if auto-fill is disabled
        if (!this.plugin.settings.enableAutoFill) {
            daySelector.settingEl.style.display = "none";
        }
        // Add initial status indicator
        const statusEl = containerEl.createEl("div", {
            cls: "fill-mode-status",
            text: this.plugin.settings.enableAutoFill
                ? "Auto-fill is active. Weeks will be filled automatically."
                : "Manual fill is active. Right-click on future weeks to mark them as filled.",
        });
        statusEl.style.fontStyle = "italic";
        statusEl.style.marginTop = "5px";
        statusEl.style.color = "var(--text-muted)";
        // Event types management section
        containerEl.createEl("h3", { text: "Event Types" });
        new obsidian.Setting(containerEl)
            .setName("Manage Event Types")
            .setDesc("Create, edit, or delete custom event types")
            .addButton((button) => {
            button.setButtonText("Manage Types").onClick(() => {
                const modal = new ManageEventTypesModal(this.app, this.plugin);
                modal.open();
            });
        });
        // Clear event data section
        containerEl.createEl("h3", { text: "Clear Event Data" });
        // Green events (Major Life Events)
        new obsidian.Setting(containerEl)
            .setName("Major Life Events")
            .setDesc("Weeks marked as Major Life Events")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.greenEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Major Life Events");
            });
        });
        // Blue events (Travel)
        new obsidian.Setting(containerEl)
            .setName("Travel Events")
            .setDesc("Weeks marked as Travel")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.blueEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Travel Events");
            });
        });
        // Pink events (Relationships)
        new obsidian.Setting(containerEl)
            .setName("Relationship Events")
            .setDesc("Weeks marked as Relationships")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.pinkEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Relationship Events");
            });
        });
        // Purple events (Education/Career)
        new obsidian.Setting(containerEl)
            .setName("Education/Career Events")
            .setDesc("Weeks marked as Education/Career")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.purpleEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Education/Career Events");
            });
        });
        // Custom events clear button (only if there are custom event types)
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEventTypes.length > 0) {
            new obsidian.Setting(containerEl)
                .setName("Custom Events")
                .setDesc("Clear events for custom event types")
                .addButton((button) => {
                button.setButtonText("Clear All Custom Events").onClick(async () => {
                    this.plugin.settings.customEvents = {};
                    for (const type of this.plugin.settings.customEventTypes) {
                        this.plugin.settings.customEvents[type.name] = [];
                    }
                    await this.plugin.saveSettings();
                    this.refreshAllViews();
                    new obsidian.Notice("Cleared all custom events");
                });
            });
            // Manual fill toggle
            new obsidian.Setting(containerEl)
                .setName("Enable Manual Fill")
                .setDesc("Allow manually marking weeks as filled by right-clicking on them")
                .addToggle((toggle) => toggle
                .setValue(this.plugin.settings.enableManualFill)
                .onChange(async (value) => {
                this.plugin.settings.enableManualFill = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            }));
            // Auto-fill toggle
            new obsidian.Setting(containerEl)
                .setName("Enable Auto-Fill")
                .setDesc("Automatically mark the current week as filled on a specific day")
                .addToggle((toggle) => toggle
                .setValue(this.plugin.settings.enableAutoFill)
                .onChange(async (value) => {
                this.plugin.settings.enableAutoFill = value;
                await this.plugin.saveSettings();
                // Show/hide day selector based on toggle state
                const daySelector = containerEl.querySelector(".auto-fill-day-selector");
                if (daySelector) {
                    daySelector.style.display = value
                        ? "flex"
                        : "none";
                }
            }));
            // Auto-fill day selector
            const daySelector = new obsidian.Setting(containerEl)
                .setName("Auto-Fill Day")
                .setDesc("Day of the week when auto-fill should occur")
                .setClass("auto-fill-day-selector")
                .addDropdown((dropdown) => {
                const days = [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                ];
                days.forEach((day, index) => {
                    dropdown.addOption(index.toString(), day);
                });
                dropdown
                    .setValue(this.plugin.settings.autoFillDay.toString())
                    .onChange(async (value) => {
                    this.plugin.settings.autoFillDay = parseInt(value);
                    await this.plugin.saveSettings();
                });
            });
            // Hide day selector if auto-fill is disabled
            if (!this.plugin.settings.enableAutoFill) {
                daySelector.settingEl.style.display = "none";
            }
            // Week start day setting
            new obsidian.Setting(containerEl)
                .setName("Start Week On Monday")
                .setDesc("Use Monday as the first day of the week (instead of Sunday)")
                .addToggle((toggle) => toggle
                .setValue(this.plugin.settings.startWeekOnMonday)
                .onChange(async (value) => {
                this.plugin.settings.startWeekOnMonday = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            }));
            // Clear filled weeks button
            new obsidian.Setting(containerEl)
                .setName("Clear Filled Weeks")
                .setDesc("Remove all filled week markings")
                .addButton((button) => {
                button.setButtonText("Clear All").onClick(async () => {
                    this.plugin.settings.filledWeeks = [];
                    await this.plugin.saveSettings();
                    this.refreshAllViews();
                    new obsidian.Notice("Cleared all filled weeks");
                });
            });
            // Default to fit to screen setting
            new obsidian.Setting(containerEl)
                .setName("Default to Fit to Screen")
                .setDesc("Automatically fit the timeline to the screen when opening the view")
                .addToggle((toggle) => toggle
                .setValue(this.plugin.settings.defaultFitToScreen)
                .onChange(async (value) => {
                this.plugin.settings.defaultFitToScreen = value;
                await this.plugin.saveSettings();
                // Show/hide the zoom level setting based on this value
                const zoomSetting = containerEl.querySelector(".zoom-level-setting");
                if (zoomSetting) {
                    zoomSetting.style.display = value
                        ? "none"
                        : "flex";
                }
            }));
            // Zoom level setting
            const zoomSetting = new obsidian.Setting(containerEl)
                .setName("Default Zoom Level")
                .setDesc("Set the default zoom level when 'Fit to Screen' is disabled (1.0 = 100%)")
                .setClass("zoom-level-setting")
                .addSlider((slider) => slider
                .setLimits(0.5, 3.0, 0.25)
                .setValue(this.plugin.settings.zoomLevel)
                .setDynamicTooltip()
                .onChange(async (value) => {
                this.plugin.settings.zoomLevel = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            }));
            // Hide zoom setting if fit to screen is enabled
            if (this.plugin.settings.defaultFitToScreen) {
                zoomSetting.settingEl.style.display = "none";
            }
            new obsidian.Setting(containerEl)
                .setName("Grid Orientation")
                .setDesc("Display years as columns/weeks as rows (landscape) or years as rows/weeks as columns (portrait)")
                .addDropdown((drop) => drop
                .addOption("landscape", "Landscape (Default)")
                .addOption("portrait", "Portrait")
                .setValue(this.plugin.settings.gridOrientation)
                .onChange(async (value) => {
                this.plugin.settings.gridOrientation = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            }));
            new obsidian.Setting(containerEl)
                .setName("Cell Shape")
                .setDesc("Square, circle, or diamond.")
                .addDropdown((drop) => drop
                .addOption("square", "Square")
                .addOption("circle", "Circle")
                .addOption("diamond", "Diamond")
                .setValue(this.plugin.settings.cellShape)
                .onChange(async (value) => {
                this.plugin.settings.cellShape = value;
                await this.plugin.saveSettings();
                // Re-render each open Chronica Timeline view so the new shape takes effect
                this.plugin.app.workspace
                    .getLeavesOfType(TIMELINE_VIEW_TYPE)
                    .forEach((leaf) => {
                    const view = leaf.view;
                    view.updateZoomLevel();
                });
            }));
            // Statistics Panel Settings
            containerEl.createEl("h3", { text: "Statistics Panel" });
            new obsidian.Setting(containerEl)
                .setName("Default Panel State")
                .setDesc("Whether the statistics panel should be open by default")
                .addToggle((toggle) => toggle
                .setValue(this.plugin.settings.isStatsOpen)
                .onChange(async (value) => {
                this.plugin.settings.isStatsOpen = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            }));
            new obsidian.Setting(containerEl)
                .setName("Default Tab")
                .setDesc("Which tab should be selected by default")
                .addDropdown((dropdown) => {
                dropdown
                    .addOption("overview", "Overview")
                    .addOption("events", "Events")
                    .addOption("timeline", "Timeline")
                    .addOption("charts", "Charts")
                    .setValue(this.plugin.settings.activeStatsTab)
                    .onChange(async (value) => {
                    this.plugin.settings.activeStatsTab = value;
                    await this.plugin.saveSettings();
                    this.refreshAllViews();
                });
            });
            new obsidian.Setting(containerEl)
                .setName("Panel Height")
                .setDesc("Default height of the statistics panel in pixels")
                .addSlider((slider) => slider
                .setLimits(150, 600, 50)
                .setValue(this.plugin.settings.statsPanelHeight)
                .setDynamicTooltip()
                .onChange(async (value) => {
                this.plugin.settings.statsPanelHeight = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            }));
        }
        // Help tips section
        containerEl.createEl("h3", { text: "Tips & Shortcuts" });
        // Create container for tips sections
        const tipsContainer = containerEl.createDiv({ cls: "chronica-tips-container" });
        // Basic Navigation section
        const navigationDetails = tipsContainer.createEl("details", { cls: "chronica-tips-details" });
        navigationDetails.createEl("summary", { text: "Basic Navigation", cls: "chronica-tips-summary" });
        const navContent = navigationDetails.createDiv({ cls: "chronica-tips-content" });
        navContent.createEl("p", { text: "• Click on any week to create or open a note for that week" });
        navContent.createEl("p", { text: "• Shift+Click on a week to quickly add an event at that date" });
        navContent.createEl("p", { text: "• Hover over a cell to see week number and date range" });
        navContent.createEl("p", { text: "• Use the zoom controls in the sidebar to adjust cell size" });
        navContent.createEl("p", { text: "• Click 'Fit to Screen' to automatically size the grid to your window" });
        // Events & Planning section
        const eventsDetails = tipsContainer.createEl("details", { cls: "chronica-tips-details" });
        eventsDetails.createEl("summary", { text: "Events & Planning", cls: "chronica-tips-summary" });
        const eventsContent = eventsDetails.createDiv({ cls: "chronica-tips-content" });
        eventsContent.createEl("p", { text: "• Use the 'Plan Event' button to mark significant life events" });
        eventsContent.createEl("p", { text: "• Create date ranges by selecting 'Date Range' in the event modal" });
        eventsContent.createEl("p", { text: "• Create custom event types with your own names and colors" });
        eventsContent.createEl("p", { text: "• Right-click on future weeks to manually mark them as filled (when auto-fill is disabled)" });
        eventsContent.createEl("p", { text: "• Events are stored as regular notes with YAML frontmatter" });
        // Customization section
        const customDetails = tipsContainer.createEl("details", { cls: "chronica-tips-details" });
        customDetails.createEl("summary", { text: "Customization", cls: "chronica-tips-summary" });
        const customContent = customDetails.createDiv({ cls: "chronica-tips-content" });
        customContent.createEl("p", { text: "• Change between square, circle, or diamond cells for different visual styles" });
        customContent.createEl("p", { text: "• Try portrait mode for an alternative timeline view (years as rows instead of columns)" });
        customContent.createEl("p", { text: "• Customize which markers appear using the marker visibility toggles" });
        customContent.createEl("p", { text: "• Adjust color schemes for past, present, and future weeks" });
        customContent.createEl("p", { text: "• Personalize the footer quote to display your own mantra or reminder" });
        // Statistics section
        const statsDetails = tipsContainer.createEl("details", { cls: "chronica-tips-details" });
        statsDetails.createEl("summary", { text: "Statistics Panel", cls: "chronica-tips-summary" });
        const statsContent = statsDetails.createDiv({ cls: "chronica-tips-content" });
        statsContent.createEl("p", { text: "• Click the 'Statistics' handle at the bottom of the screen to open the stats panel" });
        statsContent.createEl("p", { text: "• Browse different tabs to see varied visualizations of your timeline data" });
        statsContent.createEl("p", { text: "• Drag the top handle of the stats panel to resize it" });
        statsContent.createEl("p", { text: "• Analyze seasonal patterns and event distribution in the Charts tab" });
        statsContent.createEl("p", { text: "• Track your life progress and upcoming milestones in the Timeline tab" });
        // Obsidian Integration section
        const integrationDetails = tipsContainer.createEl("details", { cls: "chronica-tips-details" });
        integrationDetails.createEl("summary", { text: "Obsidian Integration", cls: "chronica-tips-summary" });
        const integrationContent = integrationDetails.createDiv({ cls: "chronica-tips-content" });
        integrationContent.createEl("p", { text: "• Weekly notes are stored as regular markdown files in your vault" });
        integrationContent.createEl("p", { text: "• Define a specific folder for all timeline notes in settings" });
        integrationContent.createEl("p", { text: "• Event metadata is stored in YAML frontmatter for compatibility with other plugins" });
        integrationContent.createEl("p", { text: "• Use Command+P (Ctrl+P) and search for 'Chronica' to access timeline commands" });
        // Set the first section to be open by default
        navigationDetails.setAttribute("open", "");
    }
    /**
     * Refresh all timeline views
     */
    refreshAllViews() {
        this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
            const view = leaf.view;
            view.renderView();
        });
    }
}

module.exports = ChronosTimelinePlugin;
//# sourceMappingURL=main.js.map
