/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source, please visit the github repository of this plugin
*/

'use strict';

var obsidian = require('obsidian');

/**
 * ChronOS Timeline Plugin for Obsidian
 *
 * A powerful visualization tool to track your life in weeks, inspired by
 * the "Life in Weeks" concept. Allows tracking of major life events,
 * reflections, and plans across multiple time scales.
 */
// -----------------------------------------------------------------------
// CONSTANTS & TYPE DEFINITIONS
// -----------------------------------------------------------------------
/** Unique identifier for the timeline view */
const TIMELINE_VIEW_TYPE = "chronos-timeline-view";
/** Default plugin settings */
const DEFAULT_SETTINGS = {
    birthday: "2003-07-18",
    lifespan: 90,
    defaultView: "weeks",
    pastCellColor: "#44cf6e",
    presentCellColor: "#a882ff",
    futureCellColor: "#d8e2e6",
    greenEvents: [],
    blueEvents: [],
    pinkEvents: [],
    purpleEvents: [],
    customEventTypes: [],
    customEvents: {},
    quote: "the only true luxury is time.",
    notesFolder: "",
    showDecadeMarkers: true,
    showWeekMarkers: true,
    showMonthMarkers: true,
    monthMarkerFrequency: 'all'
};
/** SVG icon for the ChronOS Timeline */
const CHRONOS_ICON = `<svg viewBox="0 0 100 100" width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" stroke-width="4"/>
  <line x1="50" y1="15" x2="50" y2="50" stroke="currentColor" stroke-width="4"/>
  <line x1="50" y1="50" x2="75" y2="60" stroke="currentColor" stroke-width="4"/>
  <circle cx="50" cy="50" r="5" fill="currentColor"/>
</svg>`;
/** SVG icon for birthday cake */
const CAKE_ICON = `<svg viewBox="0 0 24 24" width="16" height="16" xmlns="http://www.w3.org/2000/svg">
  <path fill="currentColor" d="M12,6C13.11,6 14,5.1 14,4C14,3.62 13.9,3.27 13.71,2.97L12,0L10.29,2.97C10.1,3.27 10,3.62 10,4A2,2 0 0,0 12,6M16.6,16L15.53,14.92L14.45,16C13.15,17.29 10.87,17.3 9.56,16L8.5,14.92L7.4,16C6.75,16.64 5.88,17 4.96,17C4.23,17 3.56,16.77 3,16.39V21A1,1 0 0,0 4,22H20A1,1 0 0,0 21,21V16.39C20.44,16.77 19.77,17 19.04,17C18.12,17 17.25,16.64 16.6,16M18,9H13V7H11V9H6A3,3 0 0,0 3,12V13.54C3,14.62 3.88,15.5 4.96,15.5C5.5,15.5 6,15.3 6.34,14.93L8.5,12.8L10.61,14.93C11.35,15.67 12.64,15.67 13.38,14.93L15.5,12.8L17.65,14.93C18,15.3 18.5,15.5 19.03,15.5C20.12,15.5 21,14.62 21,13.54V12A3,3 0 0,0 18,9Z" />
</svg>`;
// Gap between decades (larger than regular gap)
const DECADE_GAP = 6; // px
// Month names for display
const MONTH_NAMES = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
// -----------------------------------------------------------------------
// MAIN PLUGIN CLASS
// -----------------------------------------------------------------------
/**
 * Main plugin class that handles initialization, settings, and view management
 */
class ChronosTimelinePlugin extends obsidian.Plugin {
    /** Plugin settings */
    settings = DEFAULT_SETTINGS;
    /**
     * Plugin initialization on load
     */
    async onload() {
        console.log("Loading ChronOS Timeline Plugin");
        // Register the custom icon
        obsidian.addIcon("chronos-icon", CHRONOS_ICON);
        // Load settings from storage
        await this.loadSettings();
        // Register the timeline view
        this.registerView(TIMELINE_VIEW_TYPE, (leaf) => new ChronosTimelineView(leaf, this));
        // Add ribbon icon to open timeline
        this.addRibbonIcon("chronos-icon", "Open ChronOS Timeline", () => {
            this.activateView();
        });
        // Add command to open timeline
        this.addCommand({
            id: "open-chronos-timeline",
            name: "Open ChronOS Timeline",
            callback: () => {
                this.activateView();
            },
        });
        // Command to create/open weekly note
        this.addCommand({
            id: "create-weekly-note",
            name: "Create/Open Current Week Note",
            callback: () => {
                this.createOrOpenWeekNote();
            },
        });
        // Add settings tab
        this.addSettingTab(new ChronosSettingTab(this.app, this));
    }
    /**
     * Clean up on plugin unload
     */
    onunload() {
        console.log("Unloading ChronOS Timeline Plugin");
    }
    /**
     * Load settings from storage
     */
    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
        // Initialize empty arrays/objects if they don't exist
        if (!this.settings.customEventTypes) {
            this.settings.customEventTypes = [];
        }
        if (!this.settings.customEvents) {
            this.settings.customEvents = {};
        }
        // Initialize new marker settings if they don't exist
        if (this.settings.showDecadeMarkers === undefined) {
            this.settings.showDecadeMarkers = DEFAULT_SETTINGS.showDecadeMarkers;
        }
        if (this.settings.showWeekMarkers === undefined) {
            this.settings.showWeekMarkers = DEFAULT_SETTINGS.showWeekMarkers;
        }
        if (this.settings.showMonthMarkers === undefined) {
            this.settings.showMonthMarkers = DEFAULT_SETTINGS.showMonthMarkers;
        }
        if (this.settings.monthMarkerFrequency === undefined) {
            this.settings.monthMarkerFrequency = DEFAULT_SETTINGS.monthMarkerFrequency;
        }
    }
    /**
     * Save settings to storage
     */
    async saveSettings() {
        await this.saveData(this.settings);
    }
    /**
     * Show or focus the timeline view
     */
    async activateView() {
        const { workspace } = this.app;
        // Check if view is already open
        let leaf = workspace.getLeavesOfType(TIMELINE_VIEW_TYPE)[0];
        if (!leaf) {
            // Create a new leaf in the right sidebar
            leaf = workspace.getLeaf("split", "vertical");
            await leaf.setViewState({
                type: TIMELINE_VIEW_TYPE,
                active: true,
            });
        }
        // Reveal and focus the leaf
        workspace.revealLeaf(leaf);
    }
    /**
     * Calculate full weeks between birthday and given date
     * @param birthday - Birth date
     * @param today - Current or target date
     * @returns Number of full weeks between dates
     */
    getFullWeekAge(birthday, today) {
        const diffMs = today.getTime() - birthday.getTime();
        const msPerWeek = 1000 * 60 * 60 * 24 * 7;
        return Math.floor(diffMs / msPerWeek);
    }
    /**
     * Get full path for a note, using settings folder if specified
     * @param fileName - Name of the file
     * @returns Full path including folder if specified
     */
    getFullPath(fileName) {
        if (this.settings.notesFolder && this.settings.notesFolder.trim() !== "") {
            let folderPath = this.settings.notesFolder;
            if (!folderPath.endsWith("/")) {
                folderPath += "/";
            }
            return `${folderPath}${fileName}`;
        }
        return fileName;
    }
    /**
     * Create or open a note for the current week
     */
    async createOrOpenWeekNote() {
        try {
            const date = new Date();
            const year = date.getFullYear();
            const weekNum = this.getISOWeekNumber(date);
            const fileName = `${year}-W${weekNum.toString().padStart(2, "0")}.md`;
            const fullPath = this.getFullPath(fileName);
            const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
            if (existingFile instanceof obsidian.TFile) {
                // Open existing file
                await this.app.workspace.getLeaf().openFile(existingFile);
            }
            else {
                // Create folder if needed
                if (this.settings.notesFolder && this.settings.notesFolder.trim() !== "") {
                    try {
                        const folderExists = this.app.vault.getAbstractFileByPath(this.settings.notesFolder);
                        if (!folderExists) {
                            await this.app.vault.createFolder(this.settings.notesFolder);
                        }
                    }
                    catch (err) {
                        console.log("Error checking/creating folder:", err);
                    }
                }
                // Create new file with template
                const content = `# Week ${weekNum}, ${year}\n\n## Reflections\n\n## Tasks\n\n## Notes\n`;
                const newFile = await this.app.vault.create(fullPath, content);
                await this.app.workspace.getLeaf().openFile(newFile);
            }
        }
        catch (error) {
            new obsidian.Notice(`Error creating week note: ${error}`);
        }
    }
    /**
     * Calculate ISO week number for a given date
     * @param date - Date to calculate week number for
     * @returns ISO week number (1-53)
     */
    getISOWeekNumber(date) {
        const d = new Date(date);
        d.setHours(0, 0, 0, 0);
        // Set to nearest Thursday (to match ISO 8601 week start)
        d.setDate(d.getDate() + 4 - (d.getDay() || 7));
        // Get first day of the year
        const yearStart = new Date(d.getFullYear(), 0, 1);
        // Calculate full weeks between year start and current date
        return Math.ceil(((d.getTime() - yearStart.getTime()) / 86400000 + 1) / 7);
    }
    /**
     * Get week key in YYYY-WXX format from date
     * @param date - Date to get week key for
     * @returns Week key in YYYY-WXX format
     */
    getWeekKeyFromDate(date) {
        const year = date.getFullYear();
        const weekNum = this.getISOWeekNumber(date);
        return `${year}-W${weekNum.toString().padStart(2, "0")}`;
    }
    /**
     * Get all week keys between two dates
     * @param startDate - Start date
     * @param endDate - End date
     * @returns Array of week keys in YYYY-WXX format
     */
    getWeekKeysBetweenDates(startDate, endDate) {
        const weekKeys = [];
        const currentDate = new Date(startDate);
        // Ensure dates are in order
        if (startDate > endDate) {
            const temp = startDate;
            startDate = endDate;
            endDate = temp;
        }
        // Get week key for starting date
        let currentWeekKey = this.getWeekKeyFromDate(currentDate);
        weekKeys.push(currentWeekKey);
        // Advance by one week until we reach or pass the end date
        while (currentDate < endDate) {
            // Move to next week
            currentDate.setDate(currentDate.getDate() + 7);
            // Check if we've gone past the end date
            if (currentDate > endDate) {
                break;
            }
            // Get week key and add to array
            currentWeekKey = this.getWeekKeyFromDate(currentDate);
            // Only add if not already in the array (avoid duplicates)
            if (!weekKeys.includes(currentWeekKey)) {
                weekKeys.push(currentWeekKey);
            }
        }
        // Ensure the end date's week is included
        const endWeekKey = this.getWeekKeyFromDate(endDate);
        if (!weekKeys.includes(endWeekKey)) {
            weekKeys.push(endWeekKey);
        }
        return weekKeys;
    }
    /**
     * Calculate the horizontal position for a given year, accounting for decade gaps
     * @param year - Year to calculate position for (0-based index from birth)
     * @param cellSize - Size of each cell in pixels
     * @param cellGap - Standard gap between cells in pixels
     * @returns Position in pixels
     */
    calculateYearPosition(year, cellSize, cellGap) {
        // Add extra space for each completed decade
        const decades = Math.floor(year / 10);
        const extraGap = DECADE_GAP - cellGap; // Additional space for each decade
        return year * (cellSize + cellGap) + (decades * extraGap);
    }
    /**
     * Calculate month positions for vertical markers based on birth date
     * @param birthdayDate - User's birth date
     * @param totalYears - Total years to display on timeline
     * @param frequency - How often to show month markers ('all', 'quarter', 'half-year', 'year')
     * @returns Array of objects with month marker data
     */
    calculateMonthMarkers(birthdayDate, totalYears, frequency = 'all') {
        const monthMarkers = [];
        // Clone the birthday date to avoid modifying the original
        const startDate = new Date(birthdayDate);
        const birthMonth = startDate.getMonth();
        const birthYear = startDate.getFullYear();
        // Calculate the end date (birthday + total years)
        const endDate = new Date(birthdayDate);
        endDate.setFullYear(endDate.getFullYear() + totalYears);
        // Create a date iterator starting from the birthday
        const currentDate = new Date(startDate);
        // Track the last shown month to avoid duplicates
        let lastShownMonth = -1;
        let lastShownYear = -1;
        // Helper to determine if a month should be shown based on frequency
        const shouldShowMonth = (monthNum) => {
            // Always show January as the first month of the year
            if (monthNum === 0)
                return true;
            switch (frequency) {
                case 'all':
                    return true;
                case 'quarter':
                    // Show first month of each quarter (Jan, Apr, Jul, Oct)
                    return monthNum % 3 === 0;
                case 'half-year':
                    // Show first month of each half year (Jan, Jul)
                    return monthNum % 6 === 0;
                case 'year':
                    // Only show January
                    return monthNum === 0;
                default:
                    return true;
            }
        };
        // Iterate through each day until we reach the end date
        while (currentDate < endDate) {
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            // Check if this is a new month and should be shown
            if ((currentMonth !== lastShownMonth || currentYear !== lastShownYear) &&
                shouldShowMonth(currentMonth)) {
                // Calculate the exact week index based on days since birth
                const daysSinceBirth = Math.floor((currentDate.getTime() - birthdayDate.getTime()) / (1000 * 60 * 60 * 24));
                const exactWeekIndex = Math.floor(daysSinceBirth / 7);
                // Determine if this is the birth month (same month and year as birthday)
                const isBirthMonth = (currentMonth === birthMonth && currentYear === birthYear);
                // Add marker for this month
                monthMarkers.push({
                    weekIndex: exactWeekIndex,
                    label: MONTH_NAMES[currentMonth],
                    isFirstOfYear: currentMonth === 0,
                    isBirthMonth: isBirthMonth,
                    fullLabel: `${MONTH_NAMES[currentMonth]} ${currentYear}`
                });
                // Update last shown month/year
                lastShownMonth = currentMonth;
                lastShownYear = currentYear;
            }
            // Move to the next day
            currentDate.setDate(currentDate.getDate() + 1);
        }
        return monthMarkers;
    }
}
// -----------------------------------------------------------------------
// EVENT MODAL CLASS
// -----------------------------------------------------------------------
/**
 * Modal dialog for adding life events to the timeline
 */
class ChronosEventModal extends obsidian.Modal {
    /** Reference to the main plugin */
    plugin;
    /** Selected date/week (YYYY-WXX format) */
    selectedDate = "";
    /** Selected end date for range (YYYY-WXX format) */
    selectedEndDate = "";
    /** Flag to indicate if using a date range */
    isDateRange = false;
    /** Selected color for the event */
    selectedColor = "#4CAF50";
    /** Description of the event */
    eventDescription = "";
    /** Start date input field reference */
    startDateInput;
    /** End date input field reference */
    endDateInput;
    /** Currently selected event type */
    selectedEventType = "Major Life";
    /** Name for custom event type */
    customEventName = "";
    /** Flag if custom type is selected */
    isCustomType = false;
    /**
     * Create a new event modal
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     * @param preselectedDate - Optional date to preselect
     */
    constructor(app, plugin, preselectedDate = null) {
        super(app);
        this.plugin = plugin;
        if (preselectedDate) {
            if (preselectedDate.includes("W")) {
                this.selectedDate = preselectedDate;
            }
            else {
                const date = new Date(preselectedDate);
                if (!isNaN(date.getTime())) {
                    this.selectedDate = plugin.getWeekKeyFromDate(date);
                }
            }
        }
    }
    /**
     * Convert a week key (YYYY-WXX) to an approximate date (YYYY-MM-DD)
     * @param weekKey - Week key to convert
     * @returns Date string in YYYY-MM-DD format
     */
    convertWeekToDate(weekKey) {
        const parts = weekKey.split("-W");
        if (parts.length !== 2)
            return "";
        const year = parseInt(parts[0]);
        const week = parseInt(parts[1]);
        const date = new Date(year, 0, 1);
        const dayOfWeek = date.getDay();
        let daysToAdd = (week - 1) * 7;
        if (dayOfWeek <= 4) {
            daysToAdd += 1 - dayOfWeek;
        }
        else {
            daysToAdd += 8 - dayOfWeek;
        }
        date.setDate(date.getDate() + daysToAdd);
        return date.toISOString().split("T")[0];
    }
    /**
     * Build the modal UI when opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Add Life Event" });
        // Date picker section
        const dateContainer = contentEl.createDiv({
            cls: "chronos-date-picker-container"
        });
        dateContainer.createEl("h3", { text: "Select Date" });
        // Add an option to toggle between single date and date range
        const dateTypeContainer = dateContainer.createDiv({ cls: "date-type-selector" });
        const singleDateOption = dateTypeContainer.createEl("label", { cls: "date-option" });
        const singleDateRadio = singleDateOption.createEl("input", {
            type: "radio",
            attr: { name: "date-type", value: "single" }
        });
        singleDateRadio.checked = true;
        singleDateOption.createEl("span", { text: "Single Date" });
        const rangeDateOption = dateTypeContainer.createEl("label", { cls: "date-option" });
        const rangeDateRadio = rangeDateOption.createEl("input", {
            type: "radio",
            attr: { name: "date-type", value: "range" }
        });
        rangeDateOption.createEl("span", { text: "Date Range" });
        // Container for single date input
        const singleDateContainer = contentEl.createDiv({ cls: "single-date-container" });
        const singleDateSetting = new obsidian.Setting(singleDateContainer)
            .setName("Date")
            .setDesc("Enter the exact date of the event");
        this.startDateInput = singleDateSetting.controlEl.createEl("input", {
            type: "date",
            value: this.selectedDate
                ? this.convertWeekToDate(this.selectedDate)
                : new Date().toISOString().split("T")[0]
        });
        this.startDateInput.addEventListener("change", () => {
            const specificDate = this.startDateInput.value;
            if (specificDate) {
                const date = new Date(specificDate);
                this.selectedDate = this.plugin.getWeekKeyFromDate(date);
                // If using date range, initialize end date to same as start if not set
                if (this.isDateRange && !this.endDateInput.value) {
                    this.endDateInput.value = specificDate;
                    this.selectedEndDate = this.selectedDate;
                }
            }
        });
        // Container for date range inputs
        const rangeDateContainer = contentEl.createDiv({ cls: "range-date-container" });
        rangeDateContainer.style.display = "none";
        const startDateSetting = new obsidian.Setting(rangeDateContainer)
            .setName("Start Date")
            .setDesc("Enter the first date of the event range");
        this.startDateInput = startDateSetting.controlEl.createEl("input", {
            type: "date",
            value: this.selectedDate
                ? this.convertWeekToDate(this.selectedDate)
                : new Date().toISOString().split("T")[0]
        });
        this.startDateInput.addEventListener("change", () => {
            const specificDate = this.startDateInput.value;
            if (specificDate) {
                const date = new Date(specificDate);
                this.selectedDate = this.plugin.getWeekKeyFromDate(date);
            }
        });
        const endDateSetting = new obsidian.Setting(rangeDateContainer)
            .setName("End Date")
            .setDesc("Enter the last date of the event range");
        this.endDateInput = endDateSetting.controlEl.createEl("input", {
            type: "date",
            value: this.selectedEndDate
                ? this.convertWeekToDate(this.selectedEndDate)
                : this.startDateInput.value
        });
        this.endDateInput.addEventListener("change", () => {
            const specificDate = this.endDateInput.value;
            if (specificDate) {
                const date = new Date(specificDate);
                this.selectedEndDate = this.plugin.getWeekKeyFromDate(date);
            }
        });
        // Add listeners to toggle between single date and range inputs
        singleDateRadio.addEventListener("change", () => {
            if (singleDateRadio.checked) {
                this.isDateRange = false;
                singleDateContainer.style.display = "block";
                rangeDateContainer.style.display = "none";
            }
        });
        rangeDateRadio.addEventListener("change", () => {
            if (rangeDateRadio.checked) {
                this.isDateRange = true;
                singleDateContainer.style.display = "none";
                rangeDateContainer.style.display = "block";
            }
        });
        contentEl.appendChild(singleDateContainer);
        contentEl.appendChild(rangeDateContainer);
        contentEl.createEl("small", {
            text: "Select the date(s) of your event. The system determines the week(s) automatically.",
            cls: "chronos-helper-text"
        });
        if (this.selectedDate) {
            contentEl.createEl("p", {
                text: this.isDateRange
                    ? `This event spans from week ${this.selectedDate} to ${this.selectedEndDate || this.selectedDate}`
                    : `This date falls in week: ${this.selectedDate}`
            });
        }
        // Event description field
        new obsidian.Setting(contentEl)
            .setName("Description")
            .setDesc("Brief description of this event")
            .addText((text) => text.setPlaceholder("Event description").onChange((value) => {
            this.eventDescription = value;
        }));
        // Event Type Selection using radio buttons
        const eventTypeContainer = contentEl.createDiv();
        eventTypeContainer.createEl("h3", { text: "Event Type" });
        const presetTypes = [
            { name: "Major Life", color: "#4CAF50" },
            { name: "Travel", color: "#2196F3" },
            { name: "Relationship", color: "#E91E63" },
            { name: "Education/Career", color: "#9C27B0" }
        ];
        const typeSettingContainer = new obsidian.Setting(contentEl)
            .setName("Select Event Type")
            .setDesc("Choose a preset type or create your own");
        const radioContainer = typeSettingContainer.controlEl.createDiv({
            cls: "chronos-radio-container"
        });
        // Create radio buttons for preset event types
        for (const type of presetTypes) {
            const radioLabel = radioContainer.createEl("label", {
                cls: "chronos-radio-label"
            });
            const radioBtn = radioLabel.createEl("input");
            radioBtn.type = "radio";
            radioBtn.name = "eventType";
            radioBtn.value = type.name;
            if (type.name === this.selectedEventType) {
                radioBtn.checked = true;
            }
            const colorBox = radioLabel.createEl("span", {
                cls: "chronos-color-box"
            });
            colorBox.style.backgroundColor = type.color;
            radioLabel.createEl("span", { text: type.name });
            radioBtn.addEventListener("change", () => {
                if (radioBtn.checked) {
                    this.selectedEventType = type.name;
                    this.selectedColor = type.color;
                    this.isCustomType = false;
                    this.updateCustomTypeVisibility(contentEl, false);
                }
            });
        }
        // Custom event type option
        const customLabel = radioContainer.createEl("label", {
            cls: "chronos-radio-label"
        });
        const customRadio = customLabel.createEl("input");
        customRadio.type = "radio";
        customRadio.name = "eventType";
        customRadio.value = "custom";
        customLabel.createEl("span", { text: "Custom Type" });
        customRadio.addEventListener("change", () => {
            if (customRadio.checked) {
                this.isCustomType = true;
                this.updateCustomTypeVisibility(contentEl, true);
            }
        });
        // Custom type settings (initially hidden)
        const customTypeSettings = contentEl.createDiv({
            cls: "chronos-custom-type-settings"
        });
        customTypeSettings.style.display = "none";
        new obsidian.Setting(customTypeSettings)
            .setName("Custom Type Name")
            .setDesc("Enter a name for your custom event type")
            .addText((text) => text.setPlaceholder("Type name").onChange((value) => {
            this.customEventName = value;
        }));
        new obsidian.Setting(customTypeSettings)
            .setName("Custom Color")
            .setDesc("Select a color for this event type")
            .addColorPicker((picker) => {
            picker.setValue("#FF9800").onChange((value) => {
                this.selectedColor = value;
            });
            this.selectedColor = "#FF9800";
        });
        // Append custom settings to content
        contentEl.appendChild(customTypeSettings);
        // Save button
        new obsidian.Setting(contentEl).addButton((btn) => btn
            .setButtonText("Save Event")
            .setCta()
            .onClick(() => {
            this.saveEvent();
        }));
    }
    /**
     * Show or hide custom type settings
     * @param contentEl - Modal content element
     * @param show - Whether to show or hide settings
     */
    updateCustomTypeVisibility(contentEl, show) {
        const customSettings = contentEl.querySelector(".chronos-custom-type-settings");
        if (customSettings) {
            customSettings.style.display = show ? "block" : "none";
        }
    }
    /**
     * Save the event to settings and create a note
     */
    saveEvent() {
        // Validate inputs
        if (!this.selectedDate && this.startDateInput) {
            new obsidian.Notice("Please select a date");
            return;
        }
        if (!this.eventDescription) {
            new obsidian.Notice("Please add a description");
            return;
        }
        // For date range, validate end date
        if (this.isDateRange && (!this.selectedEndDate || !this.endDateInput?.value)) {
            new obsidian.Notice("Please select an end date for the range");
            return;
        }
        // Handle adding custom event type if needed
        if (this.isCustomType && this.customEventName) {
            const existingIndex = this.plugin.settings.customEventTypes.findIndex((type) => type.name === this.customEventName);
            if (existingIndex === -1) {
                this.plugin.settings.customEventTypes.push({
                    name: this.customEventName,
                    color: this.selectedColor
                });
                this.plugin.settings.customEvents[this.customEventName] = [];
            }
            this.selectedEventType = this.customEventName;
        }
        // If using date range, create events for all weeks in the range
        if (this.isDateRange && this.selectedEndDate) {
            // Get start and end dates
            const startDate = new Date(this.startDateInput.value);
            const endDate = new Date(this.endDateInput.value);
            // Get all week keys in the range
            const weekKeys = this.plugin.getWeekKeysBetweenDates(startDate, endDate);
            // Create filename for the note (use the whole range)
            const startWeekKey = this.plugin.getWeekKeyFromDate(startDate);
            const endWeekKey = this.plugin.getWeekKeyFromDate(endDate);
            const fileName = `${startWeekKey.replace("W", "-W")}_to_${endWeekKey.replace("W", "-W")}.md`;
            // Format date range event data with range markers
            const eventData = `${startWeekKey}:${endWeekKey}:${this.eventDescription}`;
            // Add event to appropriate collection
            this.addEventToCollection(eventData);
            // Create a note for the event (for the range)
            this.createEventNote(fileName, startDate, endDate);
            // Save settings
            this.plugin.saveSettings().then(() => {
                new obsidian.Notice(`Event added: ${this.eventDescription} (${weekKeys.length} weeks)`);
                this.close();
                this.refreshViews();
            });
        }
        else {
            // Handle single date event (original functionality)
            const eventDateStr = this.selectedDate || this.startDateInput.value;
            const eventDate = new Date(eventDateStr);
            const weekKey = this.plugin.getWeekKeyFromDate(eventDate);
            // Format event data string
            const eventData = `${weekKey}:${this.eventDescription}`;
            // Add event to appropriate collection
            this.addEventToCollection(eventData);
            // Create note file
            const fileName = `${weekKey.replace("W", "-W")}.md`;
            this.createEventNote(fileName, eventDate);
            // Save settings
            this.plugin.saveSettings().then(() => {
                new obsidian.Notice(`Event added: ${this.eventDescription}`);
                this.close();
                this.refreshViews();
            });
        }
    }
    /**
     * Add event to the appropriate collection based on event type
     * @param eventData - Event data string
     */
    addEventToCollection(eventData) {
        switch (this.selectedEventType) {
            case "Major Life":
                this.plugin.settings.greenEvents.push(eventData);
                break;
            case "Travel":
                this.plugin.settings.blueEvents.push(eventData);
                break;
            case "Relationship":
                this.plugin.settings.pinkEvents.push(eventData);
                break;
            case "Education/Career":
                this.plugin.settings.purpleEvents.push(eventData);
                break;
            default:
                // Custom event type
                if (!this.plugin.settings.customEvents[this.selectedEventType]) {
                    this.plugin.settings.customEvents[this.selectedEventType] = [];
                }
                this.plugin.settings.customEvents[this.selectedEventType].push(eventData);
        }
    }
    /**
     * Create a note file for the event
     * @param fileName - Name of the file
     * @param startDate - Start date of the event
     * @param endDate - Optional end date for range events
     */
    async createEventNote(fileName, startDate, endDate) {
        const fullPath = this.plugin.getFullPath(fileName);
        const fileExists = this.plugin.app.vault.getAbstractFileByPath(fullPath) instanceof obsidian.TFile;
        if (!fileExists) {
            // Create folder if needed
            if (this.plugin.settings.notesFolder && this.plugin.settings.notesFolder.trim() !== "") {
                try {
                    const folderExists = this.app.vault.getAbstractFileByPath(this.plugin.settings.notesFolder);
                    if (!folderExists) {
                        await this.app.vault.createFolder(this.plugin.settings.notesFolder);
                    }
                }
                catch (err) {
                    console.log("Error checking/creating folder:", err);
                }
            }
            // Create event note file with appropriate content
            let content = '';
            if (endDate) {
                // Range event
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                content = `# Event: ${this.eventDescription}\n\nStart Date: ${startDateStr}\nEnd Date: ${endDateStr}\nType: ${this.selectedEventType}\n\n## Notes\n\n`;
            }
            else {
                // Single date event
                const dateStr = startDate.toISOString().split('T')[0];
                content = `# Event: ${this.eventDescription}\n\nDate: ${dateStr}\nType: ${this.selectedEventType}\n\n## Notes\n\n`;
            }
            await this.app.vault.create(fullPath, content);
        }
    }
    /**
     * Refresh all timeline views
     */
    refreshViews() {
        this.plugin.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
            const view = leaf.view;
            view.renderView();
        });
    }
    /**
     * Clean up on modal close
     */
    onClose() {
        this.contentEl.empty();
    }
}
// -----------------------------------------------------------------------
// TIMELINE VIEW CLASS
// -----------------------------------------------------------------------
/**
 * Main timeline view that shows the life grid and events
 */
class ChronosTimelineView extends obsidian.ItemView {
    /** Reference to the main plugin */
    plugin;
    /**
     * Create a new timeline view
     * @param leaf - Workspace leaf to attach to
     * @param plugin - ChronosTimelinePlugin instance
     */
    constructor(leaf, plugin) {
        super(leaf);
        this.plugin = plugin;
    }
    /**
     * Get the unique view type
     */
    getViewType() {
        return TIMELINE_VIEW_TYPE;
    }
    /**
     * Get display name for the view
     */
    getDisplayText() {
        return "ChronOS Timeline";
    }
    /**
     * Get icon for the view
     */
    getIcon() {
        return "calendar-days";
    }
    /**
     * Initialize the view when opened
     */
    async onOpen() {
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
        contentEl.addClass("chronos-timeline-container");
        this.renderView();
    }
    /**
     * Clean up when view is closed
     */
    async onClose() {
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
    }
    /**
     * Render the timeline view with all components
     */
    renderView() {
        // Clear content
        const contentEl = this.containerEl.children[1];
        contentEl.empty();
        // Create title in cursive style
        contentEl.createEl("div", {
            cls: "chronos-title",
            text: "life in weeks"
        });
        // Create controls
        const controlsEl = contentEl.createEl("div", { cls: "chronos-controls" });
        // Plan future event button (keep this one as it's the main interaction point)
        const planEventBtn = controlsEl.createEl("button", {
            text: "Plan Event"
        });
        planEventBtn.addEventListener("click", () => {
            this.showAddEventModal();
        });
        // Manage event types button
        const manageTypesBtn = controlsEl.createEl("button", {
            text: "Manage Event Types"
        });
        manageTypesBtn.addEventListener("click", () => {
            const modal = new ManageEventTypesModal(this.app, this.plugin);
            modal.open();
        });
        // Add marker settings toggle button
        const markerSettingsBtn = controlsEl.createEl("button", {
            text: "Marker Settings"
        });
        markerSettingsBtn.addEventListener("click", () => {
            const modal = new MarkerSettingsModal(this.app, this.plugin, () => this.renderView());
            modal.open();
        });
        // Create the view container
        const viewEl = contentEl.createEl("div", { cls: "chronos-view" });
        // Render the weeks grid
        this.renderWeeksGrid(viewEl);
        // Create legend
        const legendEl = contentEl.createEl("div", { cls: "chronos-legend" });
        // Standard event types for legend
        const legendItems = [
            { text: "Major Life Events", color: "#4CAF50" },
            { text: "Travel", color: "#2196F3" },
            { text: "Relationships", color: "#E91E63" },
            { text: "Education/Career", color: "#9C27B0" },
            {
                text: "Upcoming Planned Event",
                color: this.plugin.settings.futureCellColor
            }
        ];
        // Add standard legend items
        legendItems.forEach((item) => {
            const itemEl = legendEl.createEl("div", { cls: "chronos-legend-item" });
            const colorEl = itemEl.createEl("div", { cls: "chronos-legend-color" });
            colorEl.style.backgroundColor = item.color;
            itemEl.createEl("span", { text: item.text });
        });
        // Render custom event type legends
        if (this.plugin.settings.customEventTypes) {
            this.plugin.settings.customEventTypes.forEach((customType) => {
                const customLegendEl = legendEl.createEl("div", {
                    cls: "chronos-legend-item"
                });
                const customColorEl = customLegendEl.createEl("div", {
                    cls: "chronos-legend-color"
                });
                customColorEl.style.backgroundColor = customType.color;
                customLegendEl.createEl("span", { text: customType.name });
            });
        }
        // Add quote at the bottom
        contentEl.createEl("div", {
            cls: "chronos-footer",
            text: this.plugin.settings.quote
        });
    }
    /**
     * Show modal for adding an event
     */
    showAddEventModal() {
        const modal = new ChronosEventModal(this.app, this.plugin);
        modal.open();
    }
    /**
     * Render the main weeks grid visualization
     * @param container - Container to render grid in
     */
    renderWeeksGrid(container) {
        container.empty();
        // Get the CSS variables for positioning and styling
        const root = document.documentElement;
        const cellSize = parseInt(getComputedStyle(root).getPropertyValue("--cell-size")) || 16;
        const cellGap = parseInt(getComputedStyle(root).getPropertyValue("--cell-gap")) || 2;
        const leftOffset = parseInt(getComputedStyle(root).getPropertyValue("--left-offset")) || 50;
        const topOffset = parseInt(getComputedStyle(root).getPropertyValue("--top-offset")) || 50;
        const regularGap = cellGap; // Store the regular gap size
        // Create decade markers container (horizontal markers above the grid)
        if (this.plugin.settings.showDecadeMarkers) {
            const decadeMarkersContainer = container.createEl("div", {
                cls: "chronos-decade-markers"
            });
            // Add decade markers (0, 10, 20, etc.)
            for (let decade = 0; decade <= this.plugin.settings.lifespan; decade += 10) {
                const marker = decadeMarkersContainer.createEl("div", {
                    cls: "chronos-decade-marker",
                    text: decade.toString()
                });
                // Position each decade marker using the calculateYearPosition method
                marker.style.position = "absolute";
                // Calculate position with the decade spacing
                const leftPosition = this.plugin.calculateYearPosition(decade, cellSize, regularGap) + cellSize / 2;
                marker.style.left = `${leftPosition}px`;
                marker.style.top = `${topOffset / 2}px`;
                marker.style.transform = "translate(-50%, -50%)";
            }
        }
        // Create vertical markers container (for both week and month markers)
        const markersContainer = container.createEl("div", {
            cls: "chronos-vertical-markers"
        });
        // Add week markers (10, 20, 30, 40, 50) if enabled
        if (this.plugin.settings.showWeekMarkers) {
            const weekMarkersContainer = markersContainer.createEl("div", {
                cls: "chronos-week-markers"
            });
            for (let week = 0; week <= 50; week += 10) {
                if (week === 0)
                    continue; // Skip 0 to start with 10
                const marker = weekMarkersContainer.createEl("div", {
                    cls: "chronos-week-marker",
                    text: week.toString()
                });
                // Position each week marker
                marker.style.position = "absolute";
                marker.style.right = "10px";
                // Move up by 1 block by subtracting (cellSize + cellGap)
                marker.style.top = `${week * (cellSize + cellGap) + cellSize / 2 - (cellSize + cellGap)}px`;
                marker.style.transform = "translateY(-50%)";
                marker.style.textAlign = "right";
            }
        }
        // Track which weeks are taken by week markers
        const weekMarkerPositions = new Set();
        if (this.plugin.settings.showWeekMarkers) {
            for (let w = 10; w <= 50; w += 10) {
                // Add the week itself plus safety buffer of -1/+1
                weekMarkerPositions.add(w - 1);
                weekMarkerPositions.add(w);
                weekMarkerPositions.add(w + 1);
            }
        }
        // Add month markers if enabled
        if (this.plugin.settings.showMonthMarkers) {
            const birthdayDate = new Date(this.plugin.settings.birthday);
            const monthMarkers = this.plugin.calculateMonthMarkers(birthdayDate, this.plugin.settings.lifespan, this.plugin.settings.monthMarkerFrequency);
            const monthMarkersContainer = markersContainer.createEl("div", {
                cls: "chronos-month-markers"
            });
            // Add each month marker
            for (const monthMarker of monthMarkers) {
                // Skip if this marker is out of bounds
                if (monthMarker.weekIndex < 0 ||
                    monthMarker.weekIndex >= this.plugin.settings.lifespan * 52) {
                    continue;
                }
                // Create the marker element
                const marker = monthMarkersContainer.createEl("div", {
                    cls: `chronos-month-marker ${monthMarker.isFirstOfYear ? 'first-of-year' : ''} ${monthMarker.isBirthMonth ? 'birth-month' : ''}`
                });
                // Show full month and year in tooltip
                marker.setAttribute("title", monthMarker.fullLabel);
                // Style the marker with position and appearance
                marker.style.position = "absolute";
                marker.style.right = "10px";
                // January gets special styling
                if (monthMarker.isFirstOfYear) {
                    marker.style.fontWeight = "bold";
                    marker.style.opacity = "1.0";
                }
                // Birth month gets cake icon
                if (monthMarker.isBirthMonth) {
                    marker.innerHTML = CAKE_ICON;
                    marker.classList.add("with-icon");
                }
                else {
                    marker.textContent = monthMarker.label;
                }
                // Check for overlap with week markers and adjust position if needed
                let offsetY = 0;
                if (weekMarkerPositions.has(monthMarker.weekIndex)) {
                    // If overlap exists, offset the month marker up slightly
                    offsetY = -12;
                    marker.classList.add("offset");
                }
                // Position the marker at the exact grid position with offset if needed
                marker.style.top = `${monthMarker.weekIndex * (cellSize + cellGap) + cellSize / 2 + offsetY}px`;
                marker.style.transform = "translateY(-50%)";
                marker.style.textAlign = "right";
            }
        }
        // Create the grid container
        const gridEl = container.createEl("div", { cls: "chronos-grid" });
        // Use display block instead of grid, as we'll manually position each cell
        gridEl.style.display = "block";
        gridEl.style.position = "absolute";
        gridEl.style.top = `${topOffset}px`;
        gridEl.style.left = `${leftOffset}px`;
        const now = new Date();
        const birthdayDate = new Date(this.plugin.settings.birthday);
        const ageInWeeks = this.plugin.getFullWeekAge(birthdayDate, now);
        // For each year, create a column of weeks
        for (let week = 0; week < 52; week++) {
            for (let year = 0; year < this.plugin.settings.lifespan; year++) {
                const weekIndex = year * 52 + week;
                const cell = gridEl.createEl("div", { cls: "chronos-grid-cell" });
                // Calculate cell date
                const cellDate = new Date(birthdayDate);
                cellDate.setDate(cellDate.getDate() + weekIndex * 7);
                const cellYear = cellDate.getFullYear();
                const cellWeek = this.plugin.getISOWeekNumber(cellDate);
                const weekKey = `${cellYear}-W${cellWeek.toString().padStart(2, "0")}`;
                cell.dataset.weekKey = weekKey;
                // Position the cell with absolute positioning
                cell.style.position = "absolute";
                // Calculate left position with decade spacing
                const leftPos = this.plugin.calculateYearPosition(year, cellSize, regularGap);
                // Calculate top position (unchanged)
                const topPos = week * (cellSize + regularGap);
                cell.style.left = `${leftPos}px`;
                cell.style.top = `${topPos}px`;
                // Explicitly set width and height (previously handled by grid)
                cell.style.width = `${cellSize}px`;
                cell.style.height = `${cellSize}px`;
                // Color coding (past, present, future)
                if (weekIndex < ageInWeeks) {
                    cell.addClass("past");
                    cell.style.backgroundColor = this.plugin.settings.pastCellColor;
                }
                else if (Math.floor(weekIndex) === Math.floor(ageInWeeks)) {
                    cell.addClass("present");
                    cell.style.backgroundColor = this.plugin.settings.presentCellColor;
                }
                else {
                    cell.addClass("future");
                    cell.style.backgroundColor = this.plugin.settings.futureCellColor;
                }
                // Apply event styling
                this.applyEventStyling(cell, weekKey);
                // Add click event to create/open the corresponding weekly note
                cell.addEventListener("click", async (event) => {
                    // If shift key is pressed, add an event
                    if (event.shiftKey) {
                        const modal = new ChronosEventModal(this.app, this.plugin, weekKey);
                        modal.open();
                        return;
                    }
                    // Otherwise open/create the weekly note
                    const fileName = `${weekKey.replace("W", "-W")}.md`;
                    const fullPath = this.plugin.getFullPath(fileName);
                    const existingFile = this.app.vault.getAbstractFileByPath(fullPath);
                    if (existingFile instanceof obsidian.TFile) {
                        // Open existing file
                        await this.app.workspace.getLeaf().openFile(existingFile);
                    }
                    else {
                        // Create new file with template
                        if (this.plugin.settings.notesFolder &&
                            this.plugin.settings.notesFolder.trim() !== "") {
                            try {
                                const folderExists = this.app.vault.getAbstractFileByPath(this.plugin.settings.notesFolder);
                                if (!folderExists) {
                                    await this.app.vault.createFolder(this.plugin.settings.notesFolder);
                                }
                            }
                            catch (err) {
                                console.log("Error checking/creating folder:", err);
                            }
                        }
                        const content = `# Week ${cellWeek}, ${cellYear}\n\n## Reflections\n\n## Tasks\n\n## Notes\n`;
                        const newFile = await this.app.vault.create(fullPath, content);
                        await this.app.workspace.getLeaf().openFile(newFile);
                    }
                });
            }
        }
    }
    /**
     * Apply styling for events to a cell
     * @param cell - Cell element to style
     * @param weekKey - Week key to check for events (YYYY-WXX)
     */
    applyEventStyling(cell, weekKey) {
        // Helper to check for range events and apply styling
        const applyEventStyle = (events, defaultColor, defaultDesc) => {
            // Check for exact match (single date events)
            const singleEvent = events.find(e => e.startsWith(`${weekKey}:`) && !e.includes(':', 10));
            if (singleEvent) {
                cell.style.backgroundColor = defaultColor;
                cell.addClass("event");
                const description = singleEvent.split(":")[1] || defaultDesc;
                cell.setAttribute("title", description);
                return true;
            }
            // Check for range events (format: startWeek:endWeek:description)
            const rangeEvents = events.filter(e => {
                const parts = e.split(":");
                return parts.length >= 3 && parts[0].includes("W") && parts[1].includes("W");
            });
            for (const rangeEvent of rangeEvents) {
                const [startWeekKey, endWeekKey, description] = rangeEvent.split(":");
                // Skip if the format is invalid
                if (!startWeekKey || !endWeekKey)
                    continue;
                // Parse the week numbers
                const startYear = parseInt(startWeekKey.split("-W")[0]);
                const startWeek = parseInt(startWeekKey.split("-W")[1]);
                const endYear = parseInt(endWeekKey.split("-W")[0]);
                const endWeek = parseInt(endWeekKey.split("-W")[1]);
                // Parse current cell week
                const cellYear = parseInt(weekKey.split("-W")[0]);
                const cellWeek = parseInt(weekKey.split("-W")[1]);
                // Check if current week falls within the range
                const isInRange = ((cellYear > startYear || (cellYear === startYear && cellWeek >= startWeek)) &&
                    (cellYear < endYear || (cellYear === endYear && cellWeek <= endWeek)));
                if (isInRange) {
                    cell.style.backgroundColor = defaultColor;
                    cell.addClass("event");
                    const eventDesc = description || defaultDesc;
                    cell.setAttribute("title", `${eventDesc} (${startWeekKey} to ${endWeekKey})`);
                    return true;
                }
            }
            return false;
        };
        // Apply event styling for each event type
        const hasGreenEvent = applyEventStyle(this.plugin.settings.greenEvents, "#4CAF50", "Major Life Event");
        if (!hasGreenEvent) {
            const hasBlueEvent = applyEventStyle(this.plugin.settings.blueEvents, "#2196F3", "Travel");
            if (!hasBlueEvent) {
                const hasPinkEvent = applyEventStyle(this.plugin.settings.pinkEvents, "#E91E63", "Relationship");
                if (!hasPinkEvent) {
                    const hasPurpleEvent = applyEventStyle(this.plugin.settings.purpleEvents, "#9C27B0", "Education/Career");
                    // Only check custom events if no built-in event was found
                    if (!hasPurpleEvent && this.plugin.settings.customEvents) {
                        for (const [typeName, events] of Object.entries(this.plugin.settings.customEvents)) {
                            const customType = this.plugin.settings.customEventTypes.find((type) => type.name === typeName);
                            if (customType && events.length > 0) {
                                applyEventStyle(events, customType.color, typeName);
                            }
                        }
                    }
                }
            }
        }
        // Highlight future events within next 6 months
        const now = new Date();
        const cellDate = new Date();
        const [cellYearStr, weekNumStr] = weekKey.split("-W");
        cellDate.setFullYear(parseInt(cellYearStr));
        cellDate.setDate(1 + (parseInt(weekNumStr) - 1) * 7);
        if (cellDate > now &&
            cellDate < new Date(now.getTime() + 6 * 30 * 24 * 60 * 60 * 1000) &&
            cell.classList.contains("event")) {
            cell.addClass("future-event-highlight");
        }
    }
}
// -----------------------------------------------------------------------
// MARKER SETTINGS MODAL
// -----------------------------------------------------------------------
/**
 * Modal for configuring which timeline markers are visible
 */
class MarkerSettingsModal extends obsidian.Modal {
    /** Reference to the main plugin */
    plugin;
    /** Callback to refresh views when settings change */
    refreshCallback;
    /**
     * Create a new marker settings modal
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     * @param refreshCallback - Callback to refresh views
     */
    constructor(app, plugin, refreshCallback) {
        super(app);
        this.plugin = plugin;
        this.refreshCallback = refreshCallback;
    }
    /**
     * Build the modal UI when opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Timeline Marker Settings" });
        contentEl.createEl("p", {
            text: "Choose which timeline markers are visible"
        });
        // Decade markers setting
        new obsidian.Setting(contentEl)
            .setName("Decade Markers")
            .setDesc("Show decade markers along the top (0, 10, 20, ...)")
            .addToggle((toggle) => {
            toggle
                .setValue(this.plugin.settings.showDecadeMarkers)
                .onChange(async (value) => {
                this.plugin.settings.showDecadeMarkers = value;
                await this.plugin.saveSettings();
                this.refreshCallback();
            });
        });
        // Week markers setting
        new obsidian.Setting(contentEl)
            .setName("Week Markers")
            .setDesc("Show week markers along the left (10, 20, 30, ...)")
            .addToggle((toggle) => {
            toggle
                .setValue(this.plugin.settings.showWeekMarkers)
                .onChange(async (value) => {
                this.plugin.settings.showWeekMarkers = value;
                await this.plugin.saveSettings();
                this.refreshCallback();
            });
        });
        // Month markers setting
        new obsidian.Setting(contentEl)
            .setName("Month Markers")
            .setDesc("Show month markers along the left side (Jan, Feb, Mar, ...)")
            .addToggle((toggle) => {
            toggle
                .setValue(this.plugin.settings.showMonthMarkers)
                .onChange(async (value) => {
                this.plugin.settings.showMonthMarkers = value;
                await this.plugin.saveSettings();
                this.refreshCallback();
            });
        });
        // Month marker frequency dropdown
        const monthMarkerSetting = new obsidian.Setting(contentEl)
            .setName("Month Marker Frequency")
            .setDesc("Choose how often month markers appear")
            .addDropdown(dropdown => {
            dropdown
                .addOption('all', 'Every Month')
                .addOption('quarter', 'Every Quarter (Jan, Apr, Jul, Oct)')
                .addOption('half-year', 'Every Half Year (Jan, Jul)')
                .addOption('year', 'Every Year (Jan only)')
                .setValue(this.plugin.settings.monthMarkerFrequency)
                .onChange(async (value) => {
                this.plugin.settings.monthMarkerFrequency = value;
                await this.plugin.saveSettings();
                this.refreshCallback();
            });
        });
        // Show or hide frequency dropdown based on month markers toggle
        monthMarkerSetting.setClass("month-marker-frequency");
        if (!this.plugin.settings.showMonthMarkers) {
            monthMarkerSetting.settingEl.style.display = "none";
        }
        // Close button
        new obsidian.Setting(contentEl)
            .addButton((btn) => btn
            .setButtonText("Close")
            .setCta()
            .onClick(() => {
            this.close();
        }));
    }
    /**
     * Clean up on modal close
     */
    onClose() {
        this.contentEl.empty();
    }
}
// -----------------------------------------------------------------------
// EVENT TYPES MODAL CLASS
// -----------------------------------------------------------------------
/**
 * Modal for managing custom event types
 */
class ManageEventTypesModal extends obsidian.Modal {
    /** Reference to the main plugin */
    plugin;
    /**
     * Create a new event types modal
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     */
    constructor(app, plugin) {
        super(app);
        this.plugin = plugin;
    }
    /**
     * Build the modal UI when opened
     */
    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Manage Event Types" });
        // Section for adding a new event type
        const addSection = contentEl.createDiv({ cls: "event-type-add-section" });
        addSection.createEl("h3", { text: "Add New Event Type" });
        const nameInput = addSection.createEl("input", {
            type: "text",
            placeholder: "Event Type Name"
        });
        const colorInput = addSection.createEl("input", {
            type: "color",
            value: "#FF9800"
        });
        const addButton = addSection.createEl("button", {
            text: "Add Type",
            cls: "add-type-button"
        });
        addButton.addEventListener("click", () => {
            const name = nameInput.value.trim();
            if (!name) {
                new obsidian.Notice("Please enter a name for the event type");
                return;
            }
            if (this.plugin.settings.customEventTypes.some((type) => type.name === name)) {
                new obsidian.Notice("An event type with this name already exists");
                return;
            }
            this.plugin.settings.customEventTypes.push({
                name: name,
                color: colorInput.value
            });
            this.plugin.settings.customEvents[name] = [];
            this.plugin.saveSettings().then(() => {
                new obsidian.Notice(`Event type "${name}" added`);
                this.renderExistingTypes(contentEl);
                nameInput.value = "";
            });
        });
        // Section for listing existing custom types
        const existingSection = contentEl.createDiv({
            cls: "event-type-existing-section"
        });
        existingSection.createEl("h3", { text: "Existing Event Types" });
        this.renderExistingTypes(existingSection);
        // Close button
        const closeButton = contentEl.createEl("button", {
            text: "Close",
            cls: "close-button"
        });
        closeButton.addEventListener("click", () => {
            this.close();
            this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
                const view = leaf.view;
                view.renderView();
            });
        });
    }
    /**
     * Render list of existing event types
     * @param container - Container element
     */
    renderExistingTypes(container) {
        // Remove existing list if present
        const typesList = container.querySelector(".existing-types-list");
        if (typesList)
            typesList.remove();
        const newList = container.createEl("div", { cls: "existing-types-list" });
        // Built-in types section
        newList.createEl("p", {
            text: "Built-in types (cannot be edited)",
            cls: "built-in-note"
        });
        const builtInTypes = [
            { name: "Major Life", color: "#4CAF50" },
            { name: "Travel", color: "#2196F3" },
            { name: "Relationship", color: "#E91E63" },
            { name: "Education/Career", color: "#9C27B0" }
        ];
        for (const type of builtInTypes) {
            const typeItem = newList.createEl("div", {
                cls: "event-type-item built-in"
            });
            const colorBox = typeItem.createEl("span", { cls: "event-type-color" });
            colorBox.style.backgroundColor = type.color;
            typeItem.createEl("span", { text: type.name, cls: "event-type-name" });
        }
        // Custom types section
        if (this.plugin.settings.customEventTypes.length > 0) {
            newList.createEl("p", {
                text: "Your custom types",
                cls: "custom-types-note"
            });
            for (const type of this.plugin.settings.customEventTypes) {
                const typeItem = newList.createEl("div", {
                    cls: "event-type-item custom"
                });
                const colorBox = typeItem.createEl("span", { cls: "event-type-color" });
                colorBox.style.backgroundColor = type.color;
                typeItem.createEl("span", { text: type.name, cls: "event-type-name" });
                // Edit button
                const editButton = typeItem.createEl("button", {
                    text: "Edit",
                    cls: "edit-type-button"
                });
                editButton.addEventListener("click", () => {
                    this.showEditTypeModal(type);
                });
                // Delete button
                const deleteButton = typeItem.createEl("button", {
                    text: "Delete",
                    cls: "delete-type-button"
                });
                deleteButton.addEventListener("click", () => {
                    if (confirm(`Are you sure you want to delete the event type "${type.name}"? All events of this type will also be deleted.`)) {
                        this.plugin.settings.customEventTypes =
                            this.plugin.settings.customEventTypes.filter((t) => t.name !== type.name);
                        delete this.plugin.settings.customEvents[type.name];
                        this.plugin.saveSettings().then(() => {
                            new obsidian.Notice(`Event type "${type.name}" deleted`);
                            this.renderExistingTypes(container);
                        });
                    }
                });
            }
        }
        else {
            newList.createEl("p", {
                text: "You haven't created any custom event types yet",
                cls: "no-custom-types"
            });
        }
    }
    /**
     * Show modal for editing an event type
     * @param type - Custom event type to edit
     */
    showEditTypeModal(type) {
        const modal = new obsidian.Modal(this.app);
        modal.titleEl.setText(`Edit Event Type: ${type.name}`);
        const contentEl = modal.contentEl;
        // Name field
        const nameContainer = contentEl.createDiv({ cls: "edit-name-container" });
        const nameLabel = nameContainer.createEl("label");
        nameLabel.textContent = "Name";
        nameLabel.htmlFor = "edit-type-name";
        const nameInput = nameContainer.createEl("input");
        nameInput.type = "text";
        nameInput.value = type.name;
        nameInput.id = "edit-type-name";
        // Color field
        const colorContainer = contentEl.createDiv({ cls: "edit-color-container" });
        const colorLabel = colorContainer.createEl("label");
        colorLabel.textContent = "Color";
        colorLabel.htmlFor = "edit-type-color";
        const colorInput = colorContainer.createEl("input");
        colorInput.type = "color";
        colorInput.value = type.color;
        colorInput.id = "edit-type-color";
        // Save button
        const saveButton = contentEl.createEl("button", {
            text: "Save Changes",
            cls: "save-edit-button"
        });
        saveButton.addEventListener("click", () => {
            const newName = nameInput.value.trim();
            if (!newName) {
                new obsidian.Notice("Please enter a name for the event type");
                return;
            }
            if (newName !== type.name &&
                this.plugin.settings.customEventTypes.some((t) => t.name === newName)) {
                new obsidian.Notice("An event type with this name already exists");
                return;
            }
            // Update name reference in events if changed
            if (newName !== type.name) {
                this.plugin.settings.customEvents[newName] =
                    this.plugin.settings.customEvents[type.name] || [];
                delete this.plugin.settings.customEvents[type.name];
            }
            // Update event type
            const typeIndex = this.plugin.settings.customEventTypes.findIndex((t) => t.name === type.name);
            if (typeIndex !== -1) {
                this.plugin.settings.customEventTypes[typeIndex] = {
                    name: newName,
                    color: colorInput.value
                };
                this.plugin.saveSettings().then(() => {
                    new obsidian.Notice(`Event type updated to "${newName}"`);
                    modal.close();
                    this.renderExistingTypes(this.contentEl);
                });
            }
        });
        // Cancel button
        const cancelButton = contentEl.createEl("button", {
            text: "Cancel",
            cls: "cancel-edit-button"
        });
        cancelButton.addEventListener("click", () => {
            modal.close();
        });
        modal.open();
    }
    /**
     * Clean up on modal close
     */
    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}
// -----------------------------------------------------------------------
// SETTINGS TAB CLASS
// -----------------------------------------------------------------------
/**
 * Settings tab for configuring the plugin
 */
class ChronosSettingTab extends obsidian.PluginSettingTab {
    /** Reference to the main plugin */
    plugin;
    /**
     * Create a new settings tab
     * @param app - Obsidian App instance
     * @param plugin - ChronosTimelinePlugin instance
     */
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    /**
     * Build the settings UI
     */
    display() {
        const { containerEl } = this;
        containerEl.empty();
        containerEl.createEl("h1", { text: "ChronOS Timeline Settings" });
        containerEl.createEl("p", {
            text: "Customize your life timeline visualization."
        });
        // Birthday setting
        new obsidian.Setting(containerEl)
            .setName("Birthday")
            .setDesc("Your date of birth (YYYY-MM-DD)")
            .addText((text) => text
            .setPlaceholder("1990-01-01")
            .setValue(this.plugin.settings.birthday)
            .onChange(async (value) => {
            this.plugin.settings.birthday = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Lifespan setting
        new obsidian.Setting(containerEl)
            .setName("Lifespan")
            .setDesc("Maximum age in years to display")
            .addSlider((slider) => slider
            .setLimits(50, 120, 5)
            .setValue(this.plugin.settings.lifespan)
            .setDynamicTooltip()
            .onChange(async (value) => {
            this.plugin.settings.lifespan = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Notes folder setting
        new obsidian.Setting(containerEl)
            .setName("Notes Folder")
            .setDesc("Where to store week notes (leave empty for vault root)")
            .addText((text) => text
            .setPlaceholder("ChronOS Notes")
            .setValue(this.plugin.settings.notesFolder || "")
            .onChange(async (value) => {
            this.plugin.settings.notesFolder = value;
            await this.plugin.saveSettings();
        }));
        // Quote setting
        new obsidian.Setting(containerEl)
            .setName("Footer Quote")
            .setDesc("Inspirational quote to display at the bottom")
            .addText((text) => text
            .setPlaceholder("the only true luxury is time.")
            .setValue(this.plugin.settings.quote)
            .onChange(async (value) => {
            this.plugin.settings.quote = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Marker visibility section
        containerEl.createEl("h3", { text: "Marker Visibility" });
        // Decade markers setting
        new obsidian.Setting(containerEl)
            .setName("Decade Markers")
            .setDesc("Show decade markers along the top (0, 10, 20, ...)")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showDecadeMarkers)
            .onChange(async (value) => {
            this.plugin.settings.showDecadeMarkers = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Week markers setting
        new obsidian.Setting(containerEl)
            .setName("Week Markers")
            .setDesc("Show week markers along the left (10, 20, 30, ...)")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showWeekMarkers)
            .onChange(async (value) => {
            this.plugin.settings.showWeekMarkers = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Month markers setting
        new obsidian.Setting(containerEl)
            .setName("Month Markers")
            .setDesc("Show month markers along the left side (Jan, Feb, Mar, ...)")
            .addToggle((toggle) => toggle
            .setValue(this.plugin.settings.showMonthMarkers)
            .onChange(async (value) => {
            this.plugin.settings.showMonthMarkers = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
            // Show/hide month marker frequency setting based on toggle state
            const freqSetting = containerEl.querySelector(".month-marker-frequency");
            if (freqSetting) {
                freqSetting.style.display = value ? "flex" : "none";
            }
        }));
        // Month marker frequency setting
        const freqSetting = new obsidian.Setting(containerEl)
            .setName("Month Marker Frequency")
            .setDesc("Choose how often month markers appear")
            .setClass("month-marker-frequency")
            .addDropdown(dropdown => {
            dropdown
                .addOption('all', 'Every Month')
                .addOption('quarter', 'Every Quarter (Jan, Apr, Jul, Oct)')
                .addOption('half-year', 'Every Half Year (Jan, Jul)')
                .addOption('year', 'Every Year (Jan only)')
                .setValue(this.plugin.settings.monthMarkerFrequency)
                .onChange(async (value) => {
                this.plugin.settings.monthMarkerFrequency = value;
                await this.plugin.saveSettings();
                this.refreshAllViews();
            });
        });
        // Hide frequency setting if month markers are disabled
        if (!this.plugin.settings.showMonthMarkers) {
            freqSetting.settingEl.style.display = "none";
        }
        // Color settings section
        containerEl.createEl("h3", { text: "Colors" });
        // Past cells color
        new obsidian.Setting(containerEl)
            .setName("Past Weeks Color")
            .setDesc("Color for weeks that have passed")
            .addColorPicker((colorPicker) => colorPicker
            .setValue(this.plugin.settings.pastCellColor)
            .onChange(async (value) => {
            this.plugin.settings.pastCellColor = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Present cell color
        new obsidian.Setting(containerEl)
            .setName("Current Week Color")
            .setDesc("Color for the current week")
            .addColorPicker((colorPicker) => colorPicker
            .setValue(this.plugin.settings.presentCellColor)
            .onChange(async (value) => {
            this.plugin.settings.presentCellColor = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Future cells color
        new obsidian.Setting(containerEl)
            .setName("Future Weeks Color")
            .setDesc("Color for weeks in the future")
            .addColorPicker((colorPicker) => colorPicker
            .setValue(this.plugin.settings.futureCellColor)
            .onChange(async (value) => {
            this.plugin.settings.futureCellColor = value;
            await this.plugin.saveSettings();
            this.refreshAllViews();
        }));
        // Event types management section
        containerEl.createEl("h3", { text: "Event Types" });
        new obsidian.Setting(containerEl)
            .setName("Manage Event Types")
            .setDesc("Create, edit, or delete custom event types")
            .addButton((button) => {
            button.setButtonText("Manage Types").onClick(() => {
                const modal = new ManageEventTypesModal(this.app, this.plugin);
                modal.open();
            });
        });
        // Clear event data section
        containerEl.createEl("h3", { text: "Clear Event Data" });
        // Green events (Major Life Events)
        new obsidian.Setting(containerEl)
            .setName("Major Life Events")
            .setDesc("Weeks marked as Major Life Events")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.greenEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Major Life Events");
            });
        });
        // Blue events (Travel)
        new obsidian.Setting(containerEl)
            .setName("Travel Events")
            .setDesc("Weeks marked as Travel")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.blueEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Travel Events");
            });
        });
        // Pink events (Relationships)
        new obsidian.Setting(containerEl)
            .setName("Relationship Events")
            .setDesc("Weeks marked as Relationships")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.pinkEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Relationship Events");
            });
        });
        // Purple events (Education/Career)
        new obsidian.Setting(containerEl)
            .setName("Education/Career Events")
            .setDesc("Weeks marked as Education/Career")
            .addButton((button) => {
            button.setButtonText("Clear All").onClick(async () => {
                this.plugin.settings.purpleEvents = [];
                await this.plugin.saveSettings();
                this.refreshAllViews();
                new obsidian.Notice("Cleared all Education/Career Events");
            });
        });
        // Custom events clear button (only if there are custom event types)
        if (this.plugin.settings.customEventTypes &&
            this.plugin.settings.customEventTypes.length > 0) {
            new obsidian.Setting(containerEl)
                .setName("Custom Events")
                .setDesc("Clear events for custom event types")
                .addButton((button) => {
                button.setButtonText("Clear All Custom Events").onClick(async () => {
                    this.plugin.settings.customEvents = {};
                    for (const type of this.plugin.settings.customEventTypes) {
                        this.plugin.settings.customEvents[type.name] = [];
                    }
                    await this.plugin.saveSettings();
                    this.refreshAllViews();
                    new obsidian.Notice("Cleared all custom events");
                });
            });
        }
        // Help tips section
        containerEl.createEl("h3", { text: "Tips" });
        containerEl.createEl("p", {
            text: " Click on any week to create or open a note for that week"
        });
        containerEl.createEl("p", {
            text: " Shift+Click on a week to add an event"
        });
        containerEl.createEl("p", {
            text: " Use the 'Plan Event' button to mark significant life events (including date ranges)"
        });
        containerEl.createEl("p", {
            text: " Create custom event types to personalize your timeline"
        });
        containerEl.createEl("p", {
            text: " Use the 'Marker Settings' button to customize which timeline markers are visible"
        });
    }
    /**
     * Refresh all timeline views
     */
    refreshAllViews() {
        this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).forEach((leaf) => {
            const view = leaf.view;
            view.renderView();
        });
    }
}

module.exports = ChronosTimelinePlugin;
//# sourceMappingURL=main.js.map
